#include "includes.h"
#include "librpc/rpc/dcerpc.h"
#include "lib/com/dcom/dcom.h"
#include "librpc/gen_ndr/com_dcom.h"
#include "libcli/composite/composite.h"
/* DCOM proxy for IUnknown generated by pidl */


static void dcom_proxy_IUnknown_QueryInterface_recv_rpc(struct rpc_request *req);

struct IUnknown_QueryInterface_out {
	struct IUnknown *data;
	WERROR result;
};

static struct composite_context *dcom_proxy_IUnknown_QueryInterface_send(struct IUnknown *d, TALLOC_CTX *mem_ctx, struct GUID *iid)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct QueryInterface *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct QueryInterface);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IUnknown;
        s->opnum = DCERPC_QUERYINTERFACE;
        s->continuation = dcom_proxy_IUnknown_QueryInterface_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.iid = iid;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(QueryInterface, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IUnknown_QueryInterface_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IUnknown_QueryInterface_out *out;
        struct QueryInterface *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_data;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IUnknown_QueryInterface_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.data = &mip_data;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(QueryInterface, r);
        }
	if (r->out.data && *r->out.data) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->data, &(**r->out.data).obj);
		if (*r->out.data) talloc_free(*r->out.data);
	} else {
		out->data = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IUnknown_QueryInterface_recv(struct composite_context *c, struct IUnknown **data)
{
        struct IUnknown_QueryInterface_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (data) *data = out->data;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IUnknown_QueryInterface(struct IUnknown *d, TALLOC_CTX *mem_ctx, struct GUID *iid, struct IUnknown **data)
{
        struct composite_context *c;

	c = IUnknown_QueryInterface_send(d, mem_ctx, iid);
	if (c == NULL) return WERR_NOMEM;

        return IUnknown_QueryInterface_recv(c, data);
}

static void dcom_proxy_IUnknown_AddRef_recv_rpc(struct rpc_request *req);

struct IUnknown_AddRef_out {
	uint32_t result;
};

static struct composite_context *dcom_proxy_IUnknown_AddRef_send(struct IUnknown *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct AddRef *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct AddRef);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IUnknown;
        s->opnum = DCERPC_ADDREF;
        s->continuation = dcom_proxy_IUnknown_AddRef_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(AddRef, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IUnknown_AddRef_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IUnknown_AddRef_out *out;
        struct AddRef *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IUnknown_AddRef_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(AddRef, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

uint32_t IUnknown_AddRef_recv(struct composite_context *c)
{
        struct IUnknown_AddRef_out *out;
        NTSTATUS status;
	uint32_t result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return 0;
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

uint32_t IUnknown_AddRef(struct IUnknown *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IUnknown_AddRef_send(d, mem_ctx);
	if (c == NULL) return 0;

        return IUnknown_AddRef_recv(c);
}

static void dcom_proxy_IUnknown_Release_recv_rpc(struct rpc_request *req);

struct IUnknown_Release_out {
	uint32_t result;
};

static struct composite_context *dcom_proxy_IUnknown_Release_send(struct IUnknown *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct Release *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct Release);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IUnknown;
        s->opnum = DCERPC_RELEASE;
        s->continuation = dcom_proxy_IUnknown_Release_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(Release, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IUnknown_Release_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IUnknown_Release_out *out;
        struct Release *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IUnknown_Release_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(Release, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

uint32_t IUnknown_Release_recv(struct composite_context *c)
{
        struct IUnknown_Release_out *out;
        NTSTATUS status;
	uint32_t result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return 0;
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

uint32_t IUnknown_Release(struct IUnknown *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IUnknown_Release_send(d, mem_ctx);
	if (c == NULL) return 0;

        return IUnknown_Release_recv(c);
}

NTSTATUS dcom_proxy_IUnknown_init(void)
{
	struct IUnknown_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IUnknown_vtable);
	proxy_vtable->QueryInterface_send = dcom_proxy_IUnknown_QueryInterface_send;
	proxy_vtable->AddRef_send = dcom_proxy_IUnknown_AddRef_send;
	proxy_vtable->Release_send = dcom_proxy_IUnknown_Release_send;

	proxy_vtable->iid = dcerpc_table_IUnknown.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IClassFactory generated by pidl */


static void dcom_proxy_IClassFactory_CreateInstance_recv_rpc(struct rpc_request *req);

struct IClassFactory_CreateInstance_out {
	struct MInterfacePointer *ppv;
	WERROR result;
};

static struct composite_context *dcom_proxy_IClassFactory_CreateInstance_send(struct IClassFactory *d, TALLOC_CTX *mem_ctx, struct MInterfacePointer *pUnknown, struct GUID *iid)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct CreateInstance *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct CreateInstance);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IClassFactory;
        s->opnum = DCERPC_CREATEINSTANCE;
        s->continuation = dcom_proxy_IClassFactory_CreateInstance_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.pUnknown = pUnknown;
	r->in.iid = iid;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(CreateInstance, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IClassFactory_CreateInstance_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IClassFactory_CreateInstance_out *out;
        struct CreateInstance *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IClassFactory_CreateInstance_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppv = &out->ppv;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(CreateInstance, r);
        }
	talloc_steal(s->mem_ctx, out->ppv);
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IClassFactory_CreateInstance_recv(struct composite_context *c, struct MInterfacePointer **ppv)
{
        struct IClassFactory_CreateInstance_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppv) *ppv = out->ppv;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IClassFactory_CreateInstance(struct IClassFactory *d, TALLOC_CTX *mem_ctx, struct MInterfacePointer *pUnknown, struct GUID *iid, struct MInterfacePointer **ppv)
{
        struct composite_context *c;

	c = IClassFactory_CreateInstance_send(d, mem_ctx, pUnknown, iid);
	if (c == NULL) return WERR_NOMEM;

        return IClassFactory_CreateInstance_recv(c, ppv);
}

static void dcom_proxy_IClassFactory_RemoteCreateInstance_recv_rpc(struct rpc_request *req);

struct IClassFactory_RemoteCreateInstance_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IClassFactory_RemoteCreateInstance_send(struct IClassFactory *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct RemoteCreateInstance *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct RemoteCreateInstance);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IClassFactory;
        s->opnum = DCERPC_REMOTECREATEINSTANCE;
        s->continuation = dcom_proxy_IClassFactory_RemoteCreateInstance_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(RemoteCreateInstance, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IClassFactory_RemoteCreateInstance_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IClassFactory_RemoteCreateInstance_out *out;
        struct RemoteCreateInstance *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IClassFactory_RemoteCreateInstance_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(RemoteCreateInstance, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IClassFactory_RemoteCreateInstance_recv(struct composite_context *c)
{
        struct IClassFactory_RemoteCreateInstance_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IClassFactory_RemoteCreateInstance(struct IClassFactory *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IClassFactory_RemoteCreateInstance_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IClassFactory_RemoteCreateInstance_recv(c);
}

static void dcom_proxy_IClassFactory_LockServer_recv_rpc(struct rpc_request *req);

struct IClassFactory_LockServer_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IClassFactory_LockServer_send(struct IClassFactory *d, TALLOC_CTX *mem_ctx, uint8_t lock)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct LockServer *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct LockServer);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IClassFactory;
        s->opnum = DCERPC_LOCKSERVER;
        s->continuation = dcom_proxy_IClassFactory_LockServer_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.lock = lock;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(LockServer, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IClassFactory_LockServer_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IClassFactory_LockServer_out *out;
        struct LockServer *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IClassFactory_LockServer_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(LockServer, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IClassFactory_LockServer_recv(struct composite_context *c)
{
        struct IClassFactory_LockServer_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IClassFactory_LockServer(struct IClassFactory *d, TALLOC_CTX *mem_ctx, uint8_t lock)
{
        struct composite_context *c;

	c = IClassFactory_LockServer_send(d, mem_ctx, lock);
	if (c == NULL) return WERR_NOMEM;

        return IClassFactory_LockServer_recv(c);
}

static void dcom_proxy_IClassFactory_RemoteLockServer_recv_rpc(struct rpc_request *req);

struct IClassFactory_RemoteLockServer_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IClassFactory_RemoteLockServer_send(struct IClassFactory *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct RemoteLockServer *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct RemoteLockServer);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IClassFactory;
        s->opnum = DCERPC_REMOTELOCKSERVER;
        s->continuation = dcom_proxy_IClassFactory_RemoteLockServer_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(RemoteLockServer, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IClassFactory_RemoteLockServer_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IClassFactory_RemoteLockServer_out *out;
        struct RemoteLockServer *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IClassFactory_RemoteLockServer_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(RemoteLockServer, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IClassFactory_RemoteLockServer_recv(struct composite_context *c)
{
        struct IClassFactory_RemoteLockServer_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IClassFactory_RemoteLockServer(struct IClassFactory *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IClassFactory_RemoteLockServer_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IClassFactory_RemoteLockServer_recv(c);
}

NTSTATUS dcom_proxy_IClassFactory_init(void)
{
	struct IClassFactory_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IClassFactory_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->CreateInstance_send = dcom_proxy_IClassFactory_CreateInstance_send;
	proxy_vtable->RemoteCreateInstance_send = dcom_proxy_IClassFactory_RemoteCreateInstance_send;
	proxy_vtable->LockServer_send = dcom_proxy_IClassFactory_LockServer_send;
	proxy_vtable->RemoteLockServer_send = dcom_proxy_IClassFactory_RemoteLockServer_send;

	proxy_vtable->iid = dcerpc_table_IClassFactory.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IRemUnknown generated by pidl */


static void dcom_proxy_IRemUnknown_RemQueryInterface_recv_rpc(struct rpc_request *req);

struct IRemUnknown_RemQueryInterface_out {
	struct REMQIRESULT *rqir;
	WERROR result;
};

static struct composite_context *dcom_proxy_IRemUnknown_RemQueryInterface_send(struct IRemUnknown *d, TALLOC_CTX *mem_ctx, struct GUID *ripid, uint32_t cRefs, uint16_t cIids, struct GUID *iids)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct RemQueryInterface *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct RemQueryInterface);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IRemUnknown;
        s->opnum = DCERPC_REMQUERYINTERFACE;
        s->continuation = dcom_proxy_IRemUnknown_RemQueryInterface_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.ripid = ripid;
	r->in.cRefs = cRefs;
	r->in.cIids = cIids;
	r->in.iids = iids;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(RemQueryInterface, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IRemUnknown_RemQueryInterface_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IRemUnknown_RemQueryInterface_out *out;
        struct RemQueryInterface *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IRemUnknown_RemQueryInterface_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.rqir = &out->rqir;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(RemQueryInterface, r);
        }
	talloc_steal(s->mem_ctx, out->rqir);
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IRemUnknown_RemQueryInterface_recv(struct composite_context *c, struct REMQIRESULT **rqir)
{
        struct IRemUnknown_RemQueryInterface_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (rqir) *rqir = out->rqir;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IRemUnknown_RemQueryInterface(struct IRemUnknown *d, TALLOC_CTX *mem_ctx, struct GUID *ripid, uint32_t cRefs, uint16_t cIids, struct GUID *iids, struct REMQIRESULT **rqir)
{
        struct composite_context *c;

	c = IRemUnknown_RemQueryInterface_send(d, mem_ctx, ripid, cRefs, cIids, iids);
	if (c == NULL) return WERR_NOMEM;

        return IRemUnknown_RemQueryInterface_recv(c, rqir);
}

static void dcom_proxy_IRemUnknown_RemAddRef_recv_rpc(struct rpc_request *req);

struct IRemUnknown_RemAddRef_out {
	WERROR *pResults;
	WERROR result;
};

static struct composite_context *dcom_proxy_IRemUnknown_RemAddRef_send(struct IRemUnknown *d, TALLOC_CTX *mem_ctx, uint16_t cInterfaceRefs, struct REMINTERFACEREF *InterfaceRefs)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct RemAddRef *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct RemAddRef);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IRemUnknown;
        s->opnum = DCERPC_REMADDREF;
        s->continuation = dcom_proxy_IRemUnknown_RemAddRef_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.cInterfaceRefs = cInterfaceRefs;
	r->in.InterfaceRefs = InterfaceRefs;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(RemAddRef, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IRemUnknown_RemAddRef_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IRemUnknown_RemAddRef_out *out;
        struct RemAddRef *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IRemUnknown_RemAddRef_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.pResults = &out->pResults;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(RemAddRef, r);
        }
	talloc_steal(s->mem_ctx, out->pResults);
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IRemUnknown_RemAddRef_recv(struct composite_context *c, WERROR **pResults)
{
        struct IRemUnknown_RemAddRef_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (pResults) *pResults = out->pResults;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IRemUnknown_RemAddRef(struct IRemUnknown *d, TALLOC_CTX *mem_ctx, uint16_t cInterfaceRefs, struct REMINTERFACEREF *InterfaceRefs, WERROR **pResults)
{
        struct composite_context *c;

	c = IRemUnknown_RemAddRef_send(d, mem_ctx, cInterfaceRefs, InterfaceRefs);
	if (c == NULL) return WERR_NOMEM;

        return IRemUnknown_RemAddRef_recv(c, pResults);
}

static void dcom_proxy_IRemUnknown_RemRelease_recv_rpc(struct rpc_request *req);

struct IRemUnknown_RemRelease_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IRemUnknown_RemRelease_send(struct IRemUnknown *d, TALLOC_CTX *mem_ctx, uint16_t cInterfaceRefs, struct REMINTERFACEREF *InterfaceRefs)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct RemRelease *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct RemRelease);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IRemUnknown;
        s->opnum = DCERPC_REMRELEASE;
        s->continuation = dcom_proxy_IRemUnknown_RemRelease_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.cInterfaceRefs = cInterfaceRefs;
	r->in.InterfaceRefs = InterfaceRefs;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(RemRelease, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IRemUnknown_RemRelease_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IRemUnknown_RemRelease_out *out;
        struct RemRelease *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IRemUnknown_RemRelease_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(RemRelease, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IRemUnknown_RemRelease_recv(struct composite_context *c)
{
        struct IRemUnknown_RemRelease_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IRemUnknown_RemRelease(struct IRemUnknown *d, TALLOC_CTX *mem_ctx, uint16_t cInterfaceRefs, struct REMINTERFACEREF *InterfaceRefs)
{
        struct composite_context *c;

	c = IRemUnknown_RemRelease_send(d, mem_ctx, cInterfaceRefs, InterfaceRefs);
	if (c == NULL) return WERR_NOMEM;

        return IRemUnknown_RemRelease_recv(c);
}

NTSTATUS dcom_proxy_IRemUnknown_init(void)
{
	struct IRemUnknown_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IRemUnknown_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->RemQueryInterface_send = dcom_proxy_IRemUnknown_RemQueryInterface_send;
	proxy_vtable->RemAddRef_send = dcom_proxy_IRemUnknown_RemAddRef_send;
	proxy_vtable->RemRelease_send = dcom_proxy_IRemUnknown_RemRelease_send;

	proxy_vtable->iid = dcerpc_table_IRemUnknown.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IClassActivator generated by pidl */


static void dcom_proxy_IClassActivator_GetClassObject_recv_rpc(struct rpc_request *req);

struct IClassActivator_GetClassObject_out {
	struct MInterfacePointer data;
};

static struct composite_context *dcom_proxy_IClassActivator_GetClassObject_send(struct IClassActivator *d, TALLOC_CTX *mem_ctx, struct GUID clsid, uint32_t context, uint32_t locale, struct GUID iid)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct GetClassObject *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct GetClassObject);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IClassActivator;
        s->opnum = DCERPC_GETCLASSOBJECT;
        s->continuation = dcom_proxy_IClassActivator_GetClassObject_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.clsid = clsid;
	r->in.context = context;
	r->in.locale = locale;
	r->in.iid = iid;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(GetClassObject, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IClassActivator_GetClassObject_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IClassActivator_GetClassObject_out *out;
        struct GetClassObject *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IClassActivator_GetClassObject_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.data = &out->data;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(GetClassObject, r);
        }

        talloc_free(s);
        composite_done(c);
}

void IClassActivator_GetClassObject_recv(struct composite_context *c, struct MInterfacePointer *data)
{
        struct IClassActivator_GetClassObject_out *out;
        NTSTATUS status;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return;
	}
        out = c->private_data;

	if (data) *data = out->data;

        talloc_free(c);

}

void IClassActivator_GetClassObject(struct IClassActivator *d, TALLOC_CTX *mem_ctx, struct GUID clsid, uint32_t context, uint32_t locale, struct GUID iid, struct MInterfacePointer *data)
{
        struct composite_context *c;

	c = IClassActivator_GetClassObject_send(d, mem_ctx, clsid, context, locale, iid);
	if (c == NULL) return;

        IClassActivator_GetClassObject_recv(c, data);
}

NTSTATUS dcom_proxy_IClassActivator_init(void)
{
	struct IClassActivator_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IClassActivator_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->GetClassObject_send = dcom_proxy_IClassActivator_GetClassObject_send;

	proxy_vtable->iid = dcerpc_table_IClassActivator.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for ISCMLocalActivator generated by pidl */


static void dcom_proxy_ISCMLocalActivator_ISCMLocalActivator_CreateInstance_recv_rpc(struct rpc_request *req);

struct ISCMLocalActivator_ISCMLocalActivator_CreateInstance_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_ISCMLocalActivator_ISCMLocalActivator_CreateInstance_send(struct ISCMLocalActivator *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct ISCMLocalActivator_CreateInstance *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct ISCMLocalActivator_CreateInstance);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_ISCMLocalActivator;
        s->opnum = DCERPC_ISCMLOCALACTIVATOR_CREATEINSTANCE;
        s->continuation = dcom_proxy_ISCMLocalActivator_ISCMLocalActivator_CreateInstance_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(ISCMLocalActivator_CreateInstance, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_ISCMLocalActivator_ISCMLocalActivator_CreateInstance_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct ISCMLocalActivator_ISCMLocalActivator_CreateInstance_out *out;
        struct ISCMLocalActivator_CreateInstance *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct ISCMLocalActivator_ISCMLocalActivator_CreateInstance_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(ISCMLocalActivator_CreateInstance, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR ISCMLocalActivator_ISCMLocalActivator_CreateInstance_recv(struct composite_context *c)
{
        struct ISCMLocalActivator_ISCMLocalActivator_CreateInstance_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR ISCMLocalActivator_CreateInstance(struct ISCMLocalActivator *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = ISCMLocalActivator_CreateInstance_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return ISCMLocalActivator_ISCMLocalActivator_CreateInstance_recv(c);
}

NTSTATUS dcom_proxy_ISCMLocalActivator_init(void)
{
	struct ISCMLocalActivator_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct ISCMLocalActivator_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IClassActivator.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IClassActivator'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IClassActivator_vtable));

	proxy_vtable->ISCMLocalActivator_CreateInstance_send = dcom_proxy_ISCMLocalActivator_ISCMLocalActivator_CreateInstance_send;

	proxy_vtable->iid = dcerpc_table_ISCMLocalActivator.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for ISystemActivator generated by pidl */


static void dcom_proxy_ISystemActivator_ISystemActivatorRemoteCreateInstance_recv_rpc(struct rpc_request *req);

struct ISystemActivator_ISystemActivatorRemoteCreateInstance_out {
	uint32_t unknown3;
	struct MInterfacePointer iface2;
	WERROR result;
};

static struct composite_context *dcom_proxy_ISystemActivator_ISystemActivatorRemoteCreateInstance_send(struct ISystemActivator *d, TALLOC_CTX *mem_ctx, uint64_t unknown1, struct MInterfacePointer iface1, uint64_t unknown2)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct ISystemActivatorRemoteCreateInstance *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct ISystemActivatorRemoteCreateInstance);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_ISystemActivator;
        s->opnum = DCERPC_ISYSTEMACTIVATORREMOTECREATEINSTANCE;
        s->continuation = dcom_proxy_ISystemActivator_ISystemActivatorRemoteCreateInstance_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.unknown1 = unknown1;
	r->in.iface1 = iface1;
	r->in.unknown2 = unknown2;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(ISystemActivatorRemoteCreateInstance, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_ISystemActivator_ISystemActivatorRemoteCreateInstance_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct ISystemActivator_ISystemActivatorRemoteCreateInstance_out *out;
        struct ISystemActivatorRemoteCreateInstance *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct ISystemActivator_ISystemActivatorRemoteCreateInstance_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.unknown3 = &out->unknown3;
	r->out.iface2 = &out->iface2;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(ISystemActivatorRemoteCreateInstance, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR ISystemActivator_ISystemActivatorRemoteCreateInstance_recv(struct composite_context *c, uint32_t *unknown3, struct MInterfacePointer *iface2)
{
        struct ISystemActivator_ISystemActivatorRemoteCreateInstance_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (unknown3) *unknown3 = out->unknown3;
	if (iface2) *iface2 = out->iface2;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR ISystemActivator_ISystemActivatorRemoteCreateInstance(struct ISystemActivator *d, TALLOC_CTX *mem_ctx, uint64_t unknown1, struct MInterfacePointer iface1, uint64_t unknown2, uint32_t *unknown3, struct MInterfacePointer *iface2)
{
        struct composite_context *c;

	c = ISystemActivator_ISystemActivatorRemoteCreateInstance_send(d, mem_ctx, unknown1, iface1, unknown2);
	if (c == NULL) return WERR_NOMEM;

        return ISystemActivator_ISystemActivatorRemoteCreateInstance_recv(c, unknown3, iface2);
}

NTSTATUS dcom_proxy_ISystemActivator_init(void)
{
	struct ISystemActivator_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct ISystemActivator_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IClassActivator.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IClassActivator'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IClassActivator_vtable));

	proxy_vtable->ISystemActivatorRemoteCreateInstance_send = dcom_proxy_ISystemActivator_ISystemActivatorRemoteCreateInstance_send;

	proxy_vtable->iid = dcerpc_table_ISystemActivator.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IRemUnknown2 generated by pidl */


static void dcom_proxy_IRemUnknown2_RemQueryInterface2_recv_rpc(struct rpc_request *req);

struct IRemUnknown2_RemQueryInterface2_out {
	WERROR *phr;
	struct MInterfacePointer *ppMIF;
	WERROR result;
};

static struct composite_context *dcom_proxy_IRemUnknown2_RemQueryInterface2_send(struct IRemUnknown2 *d, TALLOC_CTX *mem_ctx, struct GUID *ripid, uint16_t cIids, struct GUID **iids)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct RemQueryInterface2 *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct RemQueryInterface2);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IRemUnknown2;
        s->opnum = DCERPC_REMQUERYINTERFACE2;
        s->continuation = dcom_proxy_IRemUnknown2_RemQueryInterface2_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.ripid = ripid;
	r->in.cIids = cIids;
	r->in.iids = iids;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(RemQueryInterface2, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IRemUnknown2_RemQueryInterface2_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IRemUnknown2_RemQueryInterface2_out *out;
        struct RemQueryInterface2 *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IRemUnknown2_RemQueryInterface2_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.phr = &out->phr;
	r->out.ppMIF = &out->ppMIF;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(RemQueryInterface2, r);
        }
	talloc_steal(s->mem_ctx, out->phr);
	talloc_steal(s->mem_ctx, out->ppMIF);
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IRemUnknown2_RemQueryInterface2_recv(struct composite_context *c, WERROR **phr, struct MInterfacePointer **ppMIF)
{
        struct IRemUnknown2_RemQueryInterface2_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (phr) *phr = out->phr;
	if (ppMIF) *ppMIF = out->ppMIF;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IRemUnknown2_RemQueryInterface2(struct IRemUnknown2 *d, TALLOC_CTX *mem_ctx, struct GUID *ripid, uint16_t cIids, struct GUID **iids, WERROR **phr, struct MInterfacePointer **ppMIF)
{
        struct composite_context *c;

	c = IRemUnknown2_RemQueryInterface2_send(d, mem_ctx, ripid, cIids, iids);
	if (c == NULL) return WERR_NOMEM;

        return IRemUnknown2_RemQueryInterface2_recv(c, phr, ppMIF);
}

NTSTATUS dcom_proxy_IRemUnknown2_init(void)
{
	struct IRemUnknown2_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IRemUnknown2_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IRemUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IRemUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IRemUnknown_vtable));

	proxy_vtable->RemQueryInterface2_send = dcom_proxy_IRemUnknown2_RemQueryInterface2_send;

	proxy_vtable->iid = dcerpc_table_IRemUnknown2.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IDispatch generated by pidl */


static void dcom_proxy_IDispatch_GetTypeInfoCount_recv_rpc(struct rpc_request *req);

struct IDispatch_GetTypeInfoCount_out {
	uint16_t pctinfo;
	WERROR result;
};

static struct composite_context *dcom_proxy_IDispatch_GetTypeInfoCount_send(struct IDispatch *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct GetTypeInfoCount *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct GetTypeInfoCount);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IDispatch;
        s->opnum = DCERPC_GETTYPEINFOCOUNT;
        s->continuation = dcom_proxy_IDispatch_GetTypeInfoCount_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(GetTypeInfoCount, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IDispatch_GetTypeInfoCount_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IDispatch_GetTypeInfoCount_out *out;
        struct GetTypeInfoCount *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IDispatch_GetTypeInfoCount_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.pctinfo = &out->pctinfo;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(GetTypeInfoCount, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IDispatch_GetTypeInfoCount_recv(struct composite_context *c, uint16_t *pctinfo)
{
        struct IDispatch_GetTypeInfoCount_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (pctinfo) *pctinfo = out->pctinfo;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IDispatch_GetTypeInfoCount(struct IDispatch *d, TALLOC_CTX *mem_ctx, uint16_t *pctinfo)
{
        struct composite_context *c;

	c = IDispatch_GetTypeInfoCount_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IDispatch_GetTypeInfoCount_recv(c, pctinfo);
}

static void dcom_proxy_IDispatch_GetTypeInfo_recv_rpc(struct rpc_request *req);

struct IDispatch_GetTypeInfo_out {
	struct REF_ITypeInfo *ppTInfo;
	WERROR result;
};

static struct composite_context *dcom_proxy_IDispatch_GetTypeInfo_send(struct IDispatch *d, TALLOC_CTX *mem_ctx, uint16_t iTInfo, uint32_t lcid)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct GetTypeInfo *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct GetTypeInfo);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IDispatch;
        s->opnum = DCERPC_GETTYPEINFO;
        s->continuation = dcom_proxy_IDispatch_GetTypeInfo_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.iTInfo = iTInfo;
	r->in.lcid = lcid;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(GetTypeInfo, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IDispatch_GetTypeInfo_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IDispatch_GetTypeInfo_out *out;
        struct GetTypeInfo *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IDispatch_GetTypeInfo_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppTInfo = &out->ppTInfo;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(GetTypeInfo, r);
        }
	talloc_steal(s->mem_ctx, out->ppTInfo);
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IDispatch_GetTypeInfo_recv(struct composite_context *c, struct REF_ITypeInfo **ppTInfo)
{
        struct IDispatch_GetTypeInfo_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppTInfo) *ppTInfo = out->ppTInfo;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IDispatch_GetTypeInfo(struct IDispatch *d, TALLOC_CTX *mem_ctx, uint16_t iTInfo, uint32_t lcid, struct REF_ITypeInfo **ppTInfo)
{
        struct composite_context *c;

	c = IDispatch_GetTypeInfo_send(d, mem_ctx, iTInfo, lcid);
	if (c == NULL) return WERR_NOMEM;

        return IDispatch_GetTypeInfo_recv(c, ppTInfo);
}

static void dcom_proxy_IDispatch_GetIDsOfNames_recv_rpc(struct rpc_request *req);

struct IDispatch_GetIDsOfNames_out {
	uint32_t *rgDispId;
	WERROR result;
};

static struct composite_context *dcom_proxy_IDispatch_GetIDsOfNames_send(struct IDispatch *d, TALLOC_CTX *mem_ctx, struct GUID *riid, uint16_t cNames, uint32_t lcid)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct GetIDsOfNames *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct GetIDsOfNames);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IDispatch;
        s->opnum = DCERPC_GETIDSOFNAMES;
        s->continuation = dcom_proxy_IDispatch_GetIDsOfNames_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.riid = riid;
	r->in.cNames = cNames;
	r->in.lcid = lcid;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(GetIDsOfNames, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IDispatch_GetIDsOfNames_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IDispatch_GetIDsOfNames_out *out;
        struct GetIDsOfNames *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IDispatch_GetIDsOfNames_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.rgDispId = &out->rgDispId;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(GetIDsOfNames, r);
        }
	talloc_steal(s->mem_ctx, out->rgDispId);
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IDispatch_GetIDsOfNames_recv(struct composite_context *c, uint32_t **rgDispId)
{
        struct IDispatch_GetIDsOfNames_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (rgDispId) *rgDispId = out->rgDispId;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IDispatch_GetIDsOfNames(struct IDispatch *d, TALLOC_CTX *mem_ctx, struct GUID *riid, uint16_t cNames, uint32_t lcid, uint32_t **rgDispId)
{
        struct composite_context *c;

	c = IDispatch_GetIDsOfNames_send(d, mem_ctx, riid, cNames, lcid);
	if (c == NULL) return WERR_NOMEM;

        return IDispatch_GetIDsOfNames_recv(c, rgDispId);
}

static void dcom_proxy_IDispatch_Invoke_recv_rpc(struct rpc_request *req);

struct IDispatch_Invoke_out {
	struct DISPPARAMS pDispParams;
	struct VARIANT *pVarResult;
	struct EXCEPINFO *pExcepInfo;
	uint16_t *puArgErr;
	WERROR result;
};

static struct composite_context *dcom_proxy_IDispatch_Invoke_send(struct IDispatch *d, TALLOC_CTX *mem_ctx, uint32_t dispIdMember, struct GUID *riid, uint32_t lcid, uint16_t wFlags, struct DISPPARAMS *pDispParams)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct Invoke *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct Invoke);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IDispatch;
        s->opnum = DCERPC_INVOKE;
        s->continuation = dcom_proxy_IDispatch_Invoke_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.dispIdMember = dispIdMember;
	r->in.riid = riid;
	r->in.lcid = lcid;
	r->in.wFlags = wFlags;
	r->in.pDispParams = pDispParams;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(Invoke, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IDispatch_Invoke_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IDispatch_Invoke_out *out;
        struct Invoke *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IDispatch_Invoke_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.pDispParams = &out->pDispParams;
	r->out.pVarResult = &out->pVarResult;
	r->out.pExcepInfo = &out->pExcepInfo;
	r->out.puArgErr = &out->puArgErr;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(Invoke, r);
        }
	talloc_steal(s->mem_ctx, out->pVarResult);
	talloc_steal(s->mem_ctx, out->pExcepInfo);
	talloc_steal(s->mem_ctx, out->puArgErr);
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IDispatch_Invoke_recv(struct composite_context *c, struct DISPPARAMS *pDispParams, struct VARIANT **pVarResult, struct EXCEPINFO **pExcepInfo, uint16_t **puArgErr)
{
        struct IDispatch_Invoke_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (pDispParams) *pDispParams = out->pDispParams;
	if (pVarResult) *pVarResult = out->pVarResult;
	if (pExcepInfo) *pExcepInfo = out->pExcepInfo;
	if (puArgErr) *puArgErr = out->puArgErr;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IDispatch_Invoke(struct IDispatch *d, TALLOC_CTX *mem_ctx, uint32_t dispIdMember, struct GUID *riid, uint32_t lcid, uint16_t wFlags, struct DISPPARAMS *pDispParams, struct VARIANT **pVarResult, struct EXCEPINFO **pExcepInfo, uint16_t **puArgErr)
{
        struct composite_context *c;

	c = IDispatch_Invoke_send(d, mem_ctx, dispIdMember, riid, lcid, wFlags, pDispParams);
	if (c == NULL) return WERR_NOMEM;

        return IDispatch_Invoke_recv(c, pDispParams, pVarResult, pExcepInfo, puArgErr);
}

NTSTATUS dcom_proxy_IDispatch_init(void)
{
	struct IDispatch_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IDispatch_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->GetTypeInfoCount_send = dcom_proxy_IDispatch_GetTypeInfoCount_send;
	proxy_vtable->GetTypeInfo_send = dcom_proxy_IDispatch_GetTypeInfo_send;
	proxy_vtable->GetIDsOfNames_send = dcom_proxy_IDispatch_GetIDsOfNames_send;
	proxy_vtable->Invoke_send = dcom_proxy_IDispatch_Invoke_send;

	proxy_vtable->iid = dcerpc_table_IDispatch.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for ICoffeeMachine generated by pidl */


static void dcom_proxy_ICoffeeMachine_MakeCoffee_recv_rpc(struct rpc_request *req);

struct ICoffeeMachine_MakeCoffee_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_ICoffeeMachine_MakeCoffee_send(struct ICoffeeMachine *d, TALLOC_CTX *mem_ctx, const char *flavor)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct MakeCoffee *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct MakeCoffee);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_ICoffeeMachine;
        s->opnum = DCERPC_MAKECOFFEE;
        s->continuation = dcom_proxy_ICoffeeMachine_MakeCoffee_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.flavor = flavor;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(MakeCoffee, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_ICoffeeMachine_MakeCoffee_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct ICoffeeMachine_MakeCoffee_out *out;
        struct MakeCoffee *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct ICoffeeMachine_MakeCoffee_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(MakeCoffee, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR ICoffeeMachine_MakeCoffee_recv(struct composite_context *c)
{
        struct ICoffeeMachine_MakeCoffee_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR ICoffeeMachine_MakeCoffee(struct ICoffeeMachine *d, TALLOC_CTX *mem_ctx, const char *flavor)
{
        struct composite_context *c;

	c = ICoffeeMachine_MakeCoffee_send(d, mem_ctx, flavor);
	if (c == NULL) return WERR_NOMEM;

        return ICoffeeMachine_MakeCoffee_recv(c);
}

NTSTATUS dcom_proxy_ICoffeeMachine_init(void)
{
	struct ICoffeeMachine_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct ICoffeeMachine_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->MakeCoffee_send = dcom_proxy_ICoffeeMachine_MakeCoffee_send;

	proxy_vtable->iid = dcerpc_table_ICoffeeMachine.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IStream generated by pidl */


static void dcom_proxy_IStream_Read_recv_rpc(struct rpc_request *req);

struct IStream_Read_out {
	uint8_t pv;
	uint32_t num_read;
	WERROR result;
};

static struct composite_context *dcom_proxy_IStream_Read_send(struct IStream *d, TALLOC_CTX *mem_ctx, uint32_t num_requested, uint32_t *num_readx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct Read *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct Read);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IStream;
        s->opnum = DCERPC_READ;
        s->continuation = dcom_proxy_IStream_Read_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.num_requested = num_requested;
	r->in.num_readx = num_readx;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(Read, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IStream_Read_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IStream_Read_out *out;
        struct Read *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IStream_Read_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.pv = &out->pv;
	r->out.num_read = &out->num_read;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(Read, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IStream_Read_recv(struct composite_context *c, uint8_t *pv, uint32_t *num_read)
{
        struct IStream_Read_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (pv) *pv = out->pv;
	if (num_read) *num_read = out->num_read;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IStream_Read(struct IStream *d, TALLOC_CTX *mem_ctx, uint8_t *pv, uint32_t num_requested, uint32_t *num_readx, uint32_t *num_read)
{
        struct composite_context *c;

	c = IStream_Read_send(d, mem_ctx, num_requested, num_readx);
	if (c == NULL) return WERR_NOMEM;

        return IStream_Read_recv(c, pv, num_read);
}

static void dcom_proxy_IStream_Write_recv_rpc(struct rpc_request *req);

struct IStream_Write_out {
	uint32_t num_written;
	WERROR result;
};

static struct composite_context *dcom_proxy_IStream_Write_send(struct IStream *d, TALLOC_CTX *mem_ctx, uint8_t *data, uint32_t num_requested)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct Write *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct Write);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IStream;
        s->opnum = DCERPC_WRITE;
        s->continuation = dcom_proxy_IStream_Write_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.data = data;
	r->in.num_requested = num_requested;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(Write, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IStream_Write_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IStream_Write_out *out;
        struct Write *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IStream_Write_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.num_written = &out->num_written;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(Write, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IStream_Write_recv(struct composite_context *c, uint32_t *num_written)
{
        struct IStream_Write_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (num_written) *num_written = out->num_written;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IStream_Write(struct IStream *d, TALLOC_CTX *mem_ctx, uint8_t *data, uint32_t num_requested, uint32_t *num_written)
{
        struct composite_context *c;

	c = IStream_Write_send(d, mem_ctx, data, num_requested);
	if (c == NULL) return WERR_NOMEM;

        return IStream_Write_recv(c, num_written);
}

NTSTATUS dcom_proxy_IStream_init(void)
{
	struct IStream_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IStream_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->Read_send = dcom_proxy_IStream_Read_send;
	proxy_vtable->Write_send = dcom_proxy_IStream_Write_send;

	proxy_vtable->iid = dcerpc_table_IStream.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IWbemServices generated by pidl */


static void dcom_proxy_IWbemServices_OpenNamespace_recv_rpc(struct rpc_request *req);

struct IWbemServices_OpenNamespace_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_OpenNamespace_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct OpenNamespace *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct OpenNamespace);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_OPENNAMESPACE;
        s->continuation = dcom_proxy_IWbemServices_OpenNamespace_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(OpenNamespace, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_OpenNamespace_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_OpenNamespace_out *out;
        struct OpenNamespace *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_OpenNamespace_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(OpenNamespace, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_OpenNamespace_recv(struct composite_context *c)
{
        struct IWbemServices_OpenNamespace_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_OpenNamespace(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_OpenNamespace_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_OpenNamespace_recv(c);
}

static void dcom_proxy_IWbemServices_CancelAsyncCall_recv_rpc(struct rpc_request *req);

struct IWbemServices_CancelAsyncCall_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_CancelAsyncCall_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct CancelAsyncCall *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct CancelAsyncCall);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_CANCELASYNCCALL;
        s->continuation = dcom_proxy_IWbemServices_CancelAsyncCall_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(CancelAsyncCall, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_CancelAsyncCall_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_CancelAsyncCall_out *out;
        struct CancelAsyncCall *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_CancelAsyncCall_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(CancelAsyncCall, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_CancelAsyncCall_recv(struct composite_context *c)
{
        struct IWbemServices_CancelAsyncCall_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_CancelAsyncCall(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_CancelAsyncCall_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_CancelAsyncCall_recv(c);
}

static void dcom_proxy_IWbemServices_QueryObjectSink_recv_rpc(struct rpc_request *req);

struct IWbemServices_QueryObjectSink_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_QueryObjectSink_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct QueryObjectSink *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct QueryObjectSink);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_QUERYOBJECTSINK;
        s->continuation = dcom_proxy_IWbemServices_QueryObjectSink_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(QueryObjectSink, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_QueryObjectSink_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_QueryObjectSink_out *out;
        struct QueryObjectSink *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_QueryObjectSink_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(QueryObjectSink, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_QueryObjectSink_recv(struct composite_context *c)
{
        struct IWbemServices_QueryObjectSink_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_QueryObjectSink(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_QueryObjectSink_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_QueryObjectSink_recv(c);
}

static void dcom_proxy_IWbemServices_GetObject_recv_rpc(struct rpc_request *req);

struct IWbemServices_GetObject_out {
	struct IWbemClassObject *ppObject;
	struct IWbemCallResult *ppCallResult;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_GetObject_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx, BSTR strObjectPath, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemClassObject **ppObject, struct IWbemCallResult **ppCallResult)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct GetObject *r;
	NTSTATUS status;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct GetObject);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_GETOBJECT;
        s->continuation = dcom_proxy_IWbemServices_GetObject_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.strObjectPath = strObjectPath;
	r->in.lFlags = lFlags;
	if (pCtx) {
		r->in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
		(r->in.pCtx)->size = sizeof(struct OBJREF);
		status = dcom_OBJREF_from_IUnknown(&(*r->in.pCtx).obj, (struct IUnknown *)pCtx);
		if (!NT_STATUS_IS_OK(status)) {
			composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
			return c;
		}
	}
	if (ppObject) {
		r->in.ppObject = talloc_zero(mem_ctx, struct MInterfacePointer*);
		if (*ppObject) {
			*r->in.ppObject = talloc_zero(r->in.ppObject, struct MInterfacePointer);
			(*r->in.ppObject)->size = sizeof(struct OBJREF);
			status = dcom_OBJREF_from_IUnknown(&(**r->in.ppObject).obj, (struct IUnknown *)*ppObject);
			if (!NT_STATUS_IS_OK(status)) {
				composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
				return c;
			}
		}
	}
	if (ppCallResult) {
		r->in.ppCallResult = talloc_zero(mem_ctx, struct MInterfacePointer*);
		if (*ppCallResult) {
			*r->in.ppCallResult = talloc_zero(r->in.ppCallResult, struct MInterfacePointer);
			(*r->in.ppCallResult)->size = sizeof(struct OBJREF);
			status = dcom_OBJREF_from_IUnknown(&(**r->in.ppCallResult).obj, (struct IUnknown *)*ppCallResult);
			if (!NT_STATUS_IS_OK(status)) {
				composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
				return c;
			}
		}
	}

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(GetObject, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_GetObject_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_GetObject_out *out;
        struct GetObject *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_ppObject;
	struct MInterfacePointer *mip_ppCallResult;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_GetObject_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppObject = &mip_ppObject;
	r->out.ppCallResult = &mip_ppCallResult;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(GetObject, r);
        }
	if (r->out.ppObject && *r->out.ppObject) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppObject, &(**r->out.ppObject).obj);
		if (*r->out.ppObject) talloc_free(*r->out.ppObject);
	} else {
		out->ppObject = NULL;
	}
	if (r->out.ppCallResult && *r->out.ppCallResult) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppCallResult, &(**r->out.ppCallResult).obj);
		if (*r->out.ppCallResult) talloc_free(*r->out.ppCallResult);
	} else {
		out->ppCallResult = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_GetObject_recv(struct composite_context *c, struct IWbemClassObject **ppObject, struct IWbemCallResult **ppCallResult)
{
        struct IWbemServices_GetObject_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppObject) *ppObject = out->ppObject;
	if (ppCallResult) *ppCallResult = out->ppCallResult;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_GetObject(struct IWbemServices *d, TALLOC_CTX *mem_ctx, BSTR strObjectPath, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemClassObject **ppObject, struct IWbemCallResult **ppCallResult)
{
        struct composite_context *c;

	c = IWbemServices_GetObject_send(d, mem_ctx, strObjectPath, lFlags, pCtx, ppObject, ppCallResult);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_GetObject_recv(c, ppObject, ppCallResult);
}

static void dcom_proxy_IWbemServices_GetObjectAsync_recv_rpc(struct rpc_request *req);

struct IWbemServices_GetObjectAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_GetObjectAsync_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct GetObjectAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct GetObjectAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_GETOBJECTASYNC;
        s->continuation = dcom_proxy_IWbemServices_GetObjectAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(GetObjectAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_GetObjectAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_GetObjectAsync_out *out;
        struct GetObjectAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_GetObjectAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(GetObjectAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_GetObjectAsync_recv(struct composite_context *c)
{
        struct IWbemServices_GetObjectAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_GetObjectAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_GetObjectAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_GetObjectAsync_recv(c);
}

static void dcom_proxy_IWbemServices_PutClass_recv_rpc(struct rpc_request *req);

struct IWbemServices_PutClass_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_PutClass_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct PutClass *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct PutClass);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_PUTCLASS;
        s->continuation = dcom_proxy_IWbemServices_PutClass_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(PutClass, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_PutClass_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_PutClass_out *out;
        struct PutClass *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_PutClass_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(PutClass, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_PutClass_recv(struct composite_context *c)
{
        struct IWbemServices_PutClass_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_PutClass(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_PutClass_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_PutClass_recv(c);
}

static void dcom_proxy_IWbemServices_PutClassAsync_recv_rpc(struct rpc_request *req);

struct IWbemServices_PutClassAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_PutClassAsync_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct PutClassAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct PutClassAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_PUTCLASSASYNC;
        s->continuation = dcom_proxy_IWbemServices_PutClassAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(PutClassAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_PutClassAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_PutClassAsync_out *out;
        struct PutClassAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_PutClassAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(PutClassAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_PutClassAsync_recv(struct composite_context *c)
{
        struct IWbemServices_PutClassAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_PutClassAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_PutClassAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_PutClassAsync_recv(c);
}

static void dcom_proxy_IWbemServices_DeleteClass_recv_rpc(struct rpc_request *req);

struct IWbemServices_DeleteClass_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_DeleteClass_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct DeleteClass *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct DeleteClass);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_DELETECLASS;
        s->continuation = dcom_proxy_IWbemServices_DeleteClass_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(DeleteClass, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_DeleteClass_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_DeleteClass_out *out;
        struct DeleteClass *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_DeleteClass_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(DeleteClass, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_DeleteClass_recv(struct composite_context *c)
{
        struct IWbemServices_DeleteClass_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_DeleteClass(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_DeleteClass_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_DeleteClass_recv(c);
}

static void dcom_proxy_IWbemServices_DeleteClassAsync_recv_rpc(struct rpc_request *req);

struct IWbemServices_DeleteClassAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_DeleteClassAsync_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct DeleteClassAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct DeleteClassAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_DELETECLASSASYNC;
        s->continuation = dcom_proxy_IWbemServices_DeleteClassAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(DeleteClassAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_DeleteClassAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_DeleteClassAsync_out *out;
        struct DeleteClassAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_DeleteClassAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(DeleteClassAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_DeleteClassAsync_recv(struct composite_context *c)
{
        struct IWbemServices_DeleteClassAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_DeleteClassAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_DeleteClassAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_DeleteClassAsync_recv(c);
}

static void dcom_proxy_IWbemServices_CreateClassEnum_recv_rpc(struct rpc_request *req);

struct IWbemServices_CreateClassEnum_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_CreateClassEnum_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct CreateClassEnum *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct CreateClassEnum);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_CREATECLASSENUM;
        s->continuation = dcom_proxy_IWbemServices_CreateClassEnum_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(CreateClassEnum, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_CreateClassEnum_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_CreateClassEnum_out *out;
        struct CreateClassEnum *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_CreateClassEnum_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(CreateClassEnum, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_CreateClassEnum_recv(struct composite_context *c)
{
        struct IWbemServices_CreateClassEnum_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_CreateClassEnum(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_CreateClassEnum_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_CreateClassEnum_recv(c);
}

static void dcom_proxy_IWbemServices_CreateClassEnumAsync_recv_rpc(struct rpc_request *req);

struct IWbemServices_CreateClassEnumAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_CreateClassEnumAsync_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct CreateClassEnumAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct CreateClassEnumAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_CREATECLASSENUMASYNC;
        s->continuation = dcom_proxy_IWbemServices_CreateClassEnumAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(CreateClassEnumAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_CreateClassEnumAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_CreateClassEnumAsync_out *out;
        struct CreateClassEnumAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_CreateClassEnumAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(CreateClassEnumAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_CreateClassEnumAsync_recv(struct composite_context *c)
{
        struct IWbemServices_CreateClassEnumAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_CreateClassEnumAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_CreateClassEnumAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_CreateClassEnumAsync_recv(c);
}

static void dcom_proxy_IWbemServices_PutInstance_recv_rpc(struct rpc_request *req);

struct IWbemServices_PutInstance_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_PutInstance_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct PutInstance *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct PutInstance);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_PUTINSTANCE;
        s->continuation = dcom_proxy_IWbemServices_PutInstance_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(PutInstance, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_PutInstance_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_PutInstance_out *out;
        struct PutInstance *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_PutInstance_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(PutInstance, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_PutInstance_recv(struct composite_context *c)
{
        struct IWbemServices_PutInstance_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_PutInstance(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_PutInstance_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_PutInstance_recv(c);
}

static void dcom_proxy_IWbemServices_PutInstanceAsync_recv_rpc(struct rpc_request *req);

struct IWbemServices_PutInstanceAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_PutInstanceAsync_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct PutInstanceAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct PutInstanceAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_PUTINSTANCEASYNC;
        s->continuation = dcom_proxy_IWbemServices_PutInstanceAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(PutInstanceAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_PutInstanceAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_PutInstanceAsync_out *out;
        struct PutInstanceAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_PutInstanceAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(PutInstanceAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_PutInstanceAsync_recv(struct composite_context *c)
{
        struct IWbemServices_PutInstanceAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_PutInstanceAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_PutInstanceAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_PutInstanceAsync_recv(c);
}

static void dcom_proxy_IWbemServices_DeleteInstance_recv_rpc(struct rpc_request *req);

struct IWbemServices_DeleteInstance_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_DeleteInstance_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct DeleteInstance *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct DeleteInstance);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_DELETEINSTANCE;
        s->continuation = dcom_proxy_IWbemServices_DeleteInstance_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(DeleteInstance, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_DeleteInstance_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_DeleteInstance_out *out;
        struct DeleteInstance *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_DeleteInstance_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(DeleteInstance, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_DeleteInstance_recv(struct composite_context *c)
{
        struct IWbemServices_DeleteInstance_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_DeleteInstance(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_DeleteInstance_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_DeleteInstance_recv(c);
}

static void dcom_proxy_IWbemServices_DeleteInstanceAsync_recv_rpc(struct rpc_request *req);

struct IWbemServices_DeleteInstanceAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_DeleteInstanceAsync_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct DeleteInstanceAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct DeleteInstanceAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_DELETEINSTANCEASYNC;
        s->continuation = dcom_proxy_IWbemServices_DeleteInstanceAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(DeleteInstanceAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_DeleteInstanceAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_DeleteInstanceAsync_out *out;
        struct DeleteInstanceAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_DeleteInstanceAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(DeleteInstanceAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_DeleteInstanceAsync_recv(struct composite_context *c)
{
        struct IWbemServices_DeleteInstanceAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_DeleteInstanceAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_DeleteInstanceAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_DeleteInstanceAsync_recv(c);
}

static void dcom_proxy_IWbemServices_CreateInstanceEnum_recv_rpc(struct rpc_request *req);

struct IWbemServices_CreateInstanceEnum_out {
	struct IEnumWbemClassObject *ppEnum;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_CreateInstanceEnum_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx, BSTR strFilter, int32_t lFlags, struct IWbemContext *pCtx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct CreateInstanceEnum *r;
	NTSTATUS status;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct CreateInstanceEnum);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_CREATEINSTANCEENUM;
        s->continuation = dcom_proxy_IWbemServices_CreateInstanceEnum_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.strFilter = strFilter;
	r->in.lFlags = lFlags;
	if (pCtx) {
		r->in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
		(r->in.pCtx)->size = sizeof(struct OBJREF);
		status = dcom_OBJREF_from_IUnknown(&(*r->in.pCtx).obj, (struct IUnknown *)pCtx);
		if (!NT_STATUS_IS_OK(status)) {
			composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
			return c;
		}
	}

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(CreateInstanceEnum, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_CreateInstanceEnum_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_CreateInstanceEnum_out *out;
        struct CreateInstanceEnum *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_ppEnum;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_CreateInstanceEnum_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppEnum = &mip_ppEnum;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(CreateInstanceEnum, r);
        }
	if (r->out.ppEnum && *r->out.ppEnum) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppEnum, &(**r->out.ppEnum).obj);
		if (*r->out.ppEnum) talloc_free(*r->out.ppEnum);
	} else {
		out->ppEnum = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_CreateInstanceEnum_recv(struct composite_context *c, struct IEnumWbemClassObject **ppEnum)
{
        struct IWbemServices_CreateInstanceEnum_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppEnum) *ppEnum = out->ppEnum;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_CreateInstanceEnum(struct IWbemServices *d, TALLOC_CTX *mem_ctx, BSTR strFilter, int32_t lFlags, struct IWbemContext *pCtx, struct IEnumWbemClassObject **ppEnum)
{
        struct composite_context *c;

	c = IWbemServices_CreateInstanceEnum_send(d, mem_ctx, strFilter, lFlags, pCtx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_CreateInstanceEnum_recv(c, ppEnum);
}

static void dcom_proxy_IWbemServices_CreateInstanceEnumAsync_recv_rpc(struct rpc_request *req);

struct IWbemServices_CreateInstanceEnumAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_CreateInstanceEnumAsync_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct CreateInstanceEnumAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct CreateInstanceEnumAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_CREATEINSTANCEENUMASYNC;
        s->continuation = dcom_proxy_IWbemServices_CreateInstanceEnumAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(CreateInstanceEnumAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_CreateInstanceEnumAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_CreateInstanceEnumAsync_out *out;
        struct CreateInstanceEnumAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_CreateInstanceEnumAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(CreateInstanceEnumAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_CreateInstanceEnumAsync_recv(struct composite_context *c)
{
        struct IWbemServices_CreateInstanceEnumAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_CreateInstanceEnumAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_CreateInstanceEnumAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_CreateInstanceEnumAsync_recv(c);
}

static void dcom_proxy_IWbemServices_ExecQuery_recv_rpc(struct rpc_request *req);

struct IWbemServices_ExecQuery_out {
	struct IEnumWbemClassObject *ppEnum;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_ExecQuery_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx, BSTR strQueryLanguage, BSTR strQuery, int32_t lFlags, struct IWbemContext *pCtx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct ExecQuery *r;
	NTSTATUS status;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct ExecQuery);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_EXECQUERY;
        s->continuation = dcom_proxy_IWbemServices_ExecQuery_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.strQueryLanguage = strQueryLanguage;
	r->in.strQuery = strQuery;
	r->in.lFlags = lFlags;
	if (pCtx) {
		r->in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
		(r->in.pCtx)->size = sizeof(struct OBJREF);
		status = dcom_OBJREF_from_IUnknown(&(*r->in.pCtx).obj, (struct IUnknown *)pCtx);
		if (!NT_STATUS_IS_OK(status)) {
			composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
			return c;
		}
	}

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(ExecQuery, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_ExecQuery_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_ExecQuery_out *out;
        struct ExecQuery *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_ppEnum;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_ExecQuery_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppEnum = &mip_ppEnum;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(ExecQuery, r);
        }
	if (r->out.ppEnum && *r->out.ppEnum) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppEnum, &(**r->out.ppEnum).obj);
		if (*r->out.ppEnum) talloc_free(*r->out.ppEnum);
	} else {
		out->ppEnum = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_ExecQuery_recv(struct composite_context *c, struct IEnumWbemClassObject **ppEnum)
{
        struct IWbemServices_ExecQuery_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppEnum) *ppEnum = out->ppEnum;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_ExecQuery(struct IWbemServices *d, TALLOC_CTX *mem_ctx, BSTR strQueryLanguage, BSTR strQuery, int32_t lFlags, struct IWbemContext *pCtx, struct IEnumWbemClassObject **ppEnum)
{
        struct composite_context *c;

	c = IWbemServices_ExecQuery_send(d, mem_ctx, strQueryLanguage, strQuery, lFlags, pCtx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_ExecQuery_recv(c, ppEnum);
}

static void dcom_proxy_IWbemServices_ExecQueryAsync_recv_rpc(struct rpc_request *req);

struct IWbemServices_ExecQueryAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_ExecQueryAsync_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct ExecQueryAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct ExecQueryAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_EXECQUERYASYNC;
        s->continuation = dcom_proxy_IWbemServices_ExecQueryAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(ExecQueryAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_ExecQueryAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_ExecQueryAsync_out *out;
        struct ExecQueryAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_ExecQueryAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(ExecQueryAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_ExecQueryAsync_recv(struct composite_context *c)
{
        struct IWbemServices_ExecQueryAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_ExecQueryAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_ExecQueryAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_ExecQueryAsync_recv(c);
}

static void dcom_proxy_IWbemServices_ExecNotificationQuery_recv_rpc(struct rpc_request *req);

struct IWbemServices_ExecNotificationQuery_out {
	struct IEnumWbemClassObject *ppEnum;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_ExecNotificationQuery_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx, BSTR strQueryLanguage, BSTR strQuery, int32_t lFlags, struct IWbemContext *pCtx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct ExecNotificationQuery *r;
	NTSTATUS status;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct ExecNotificationQuery);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_EXECNOTIFICATIONQUERY;
        s->continuation = dcom_proxy_IWbemServices_ExecNotificationQuery_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.strQueryLanguage = strQueryLanguage;
	r->in.strQuery = strQuery;
	r->in.lFlags = lFlags;
	if (pCtx) {
		r->in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
		(r->in.pCtx)->size = sizeof(struct OBJREF);
		status = dcom_OBJREF_from_IUnknown(&(*r->in.pCtx).obj, (struct IUnknown *)pCtx);
		if (!NT_STATUS_IS_OK(status)) {
			composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
			return c;
		}
	}

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(ExecNotificationQuery, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_ExecNotificationQuery_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_ExecNotificationQuery_out *out;
        struct ExecNotificationQuery *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_ppEnum;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_ExecNotificationQuery_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppEnum = &mip_ppEnum;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(ExecNotificationQuery, r);
        }
	if (r->out.ppEnum && *r->out.ppEnum) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppEnum, &(**r->out.ppEnum).obj);
		if (*r->out.ppEnum) talloc_free(*r->out.ppEnum);
	} else {
		out->ppEnum = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_ExecNotificationQuery_recv(struct composite_context *c, struct IEnumWbemClassObject **ppEnum)
{
        struct IWbemServices_ExecNotificationQuery_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppEnum) *ppEnum = out->ppEnum;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_ExecNotificationQuery(struct IWbemServices *d, TALLOC_CTX *mem_ctx, BSTR strQueryLanguage, BSTR strQuery, int32_t lFlags, struct IWbemContext *pCtx, struct IEnumWbemClassObject **ppEnum)
{
        struct composite_context *c;

	c = IWbemServices_ExecNotificationQuery_send(d, mem_ctx, strQueryLanguage, strQuery, lFlags, pCtx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_ExecNotificationQuery_recv(c, ppEnum);
}

static void dcom_proxy_IWbemServices_ExecNotificationQueryAsync_recv_rpc(struct rpc_request *req);

struct IWbemServices_ExecNotificationQueryAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_ExecNotificationQueryAsync_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct ExecNotificationQueryAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct ExecNotificationQueryAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_EXECNOTIFICATIONQUERYASYNC;
        s->continuation = dcom_proxy_IWbemServices_ExecNotificationQueryAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(ExecNotificationQueryAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_ExecNotificationQueryAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_ExecNotificationQueryAsync_out *out;
        struct ExecNotificationQueryAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_ExecNotificationQueryAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(ExecNotificationQueryAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_ExecNotificationQueryAsync_recv(struct composite_context *c)
{
        struct IWbemServices_ExecNotificationQueryAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_ExecNotificationQueryAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_ExecNotificationQueryAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_ExecNotificationQueryAsync_recv(c);
}

static void dcom_proxy_IWbemServices_ExecMethod_recv_rpc(struct rpc_request *req);

struct IWbemServices_ExecMethod_out {
	struct IWbemClassObject *ppOutParams;
	struct IWbemCallResult *ppCallResult;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_ExecMethod_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx, BSTR strObjectPath, BSTR strMethodName, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemClassObject *pInParams, struct IWbemClassObject **ppOutParams, struct IWbemCallResult **ppCallResult)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct ExecMethod *r;
	NTSTATUS status;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct ExecMethod);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_EXECMETHOD;
        s->continuation = dcom_proxy_IWbemServices_ExecMethod_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.strObjectPath = strObjectPath;
	r->in.strMethodName = strMethodName;
	r->in.lFlags = lFlags;
	if (pCtx) {
		r->in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
		(r->in.pCtx)->size = sizeof(struct OBJREF);
		status = dcom_OBJREF_from_IUnknown(&(*r->in.pCtx).obj, (struct IUnknown *)pCtx);
		if (!NT_STATUS_IS_OK(status)) {
			composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
			return c;
		}
	}
	if (pInParams) {
		r->in.pInParams = talloc_zero(mem_ctx, struct MInterfacePointer);
		(r->in.pInParams)->size = sizeof(struct OBJREF);
		status = dcom_OBJREF_from_IUnknown(&(*r->in.pInParams).obj, (struct IUnknown *)pInParams);
		if (!NT_STATUS_IS_OK(status)) {
			composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
			return c;
		}
	}
	if (ppOutParams) {
		r->in.ppOutParams = talloc_zero(mem_ctx, struct MInterfacePointer*);
		if (*ppOutParams) {
			*r->in.ppOutParams = talloc_zero(r->in.ppOutParams, struct MInterfacePointer);
			(*r->in.ppOutParams)->size = sizeof(struct OBJREF);
			status = dcom_OBJREF_from_IUnknown(&(**r->in.ppOutParams).obj, (struct IUnknown *)*ppOutParams);
			if (!NT_STATUS_IS_OK(status)) {
				composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
				return c;
			}
		}
	}
	if (ppCallResult) {
		r->in.ppCallResult = talloc_zero(mem_ctx, struct MInterfacePointer*);
		if (*ppCallResult) {
			*r->in.ppCallResult = talloc_zero(r->in.ppCallResult, struct MInterfacePointer);
			(*r->in.ppCallResult)->size = sizeof(struct OBJREF);
			status = dcom_OBJREF_from_IUnknown(&(**r->in.ppCallResult).obj, (struct IUnknown *)*ppCallResult);
			if (!NT_STATUS_IS_OK(status)) {
				composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
				return c;
			}
		}
	}

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(ExecMethod, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_ExecMethod_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_ExecMethod_out *out;
        struct ExecMethod *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_ppOutParams;
	struct MInterfacePointer *mip_ppCallResult;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_ExecMethod_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppOutParams = &mip_ppOutParams;
	r->out.ppCallResult = &mip_ppCallResult;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(ExecMethod, r);
        }
	if (r->out.ppOutParams && *r->out.ppOutParams) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppOutParams, &(**r->out.ppOutParams).obj);
		if (*r->out.ppOutParams) talloc_free(*r->out.ppOutParams);
	} else {
		out->ppOutParams = NULL;
	}
	if (r->out.ppCallResult && *r->out.ppCallResult) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppCallResult, &(**r->out.ppCallResult).obj);
		if (*r->out.ppCallResult) talloc_free(*r->out.ppCallResult);
	} else {
		out->ppCallResult = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_ExecMethod_recv(struct composite_context *c, struct IWbemClassObject **ppOutParams, struct IWbemCallResult **ppCallResult)
{
        struct IWbemServices_ExecMethod_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppOutParams) *ppOutParams = out->ppOutParams;
	if (ppCallResult) *ppCallResult = out->ppCallResult;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_ExecMethod(struct IWbemServices *d, TALLOC_CTX *mem_ctx, BSTR strObjectPath, BSTR strMethodName, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemClassObject *pInParams, struct IWbemClassObject **ppOutParams, struct IWbemCallResult **ppCallResult)
{
        struct composite_context *c;

	c = IWbemServices_ExecMethod_send(d, mem_ctx, strObjectPath, strMethodName, lFlags, pCtx, pInParams, ppOutParams, ppCallResult);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_ExecMethod_recv(c, ppOutParams, ppCallResult);
}

static void dcom_proxy_IWbemServices_ExecMethodAsync_recv_rpc(struct rpc_request *req);

struct IWbemServices_ExecMethodAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemServices_ExecMethodAsync_send(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct ExecMethodAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct ExecMethodAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemServices;
        s->opnum = DCERPC_EXECMETHODASYNC;
        s->continuation = dcom_proxy_IWbemServices_ExecMethodAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(ExecMethodAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemServices_ExecMethodAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemServices_ExecMethodAsync_out *out;
        struct ExecMethodAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemServices_ExecMethodAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(ExecMethodAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemServices_ExecMethodAsync_recv(struct composite_context *c)
{
        struct IWbemServices_ExecMethodAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemServices_ExecMethodAsync(struct IWbemServices *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemServices_ExecMethodAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemServices_ExecMethodAsync_recv(c);
}

NTSTATUS dcom_proxy_IWbemServices_init(void)
{
	struct IWbemServices_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IWbemServices_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->OpenNamespace_send = dcom_proxy_IWbemServices_OpenNamespace_send;
	proxy_vtable->CancelAsyncCall_send = dcom_proxy_IWbemServices_CancelAsyncCall_send;
	proxy_vtable->QueryObjectSink_send = dcom_proxy_IWbemServices_QueryObjectSink_send;
	proxy_vtable->GetObject_send = dcom_proxy_IWbemServices_GetObject_send;
	proxy_vtable->GetObjectAsync_send = dcom_proxy_IWbemServices_GetObjectAsync_send;
	proxy_vtable->PutClass_send = dcom_proxy_IWbemServices_PutClass_send;
	proxy_vtable->PutClassAsync_send = dcom_proxy_IWbemServices_PutClassAsync_send;
	proxy_vtable->DeleteClass_send = dcom_proxy_IWbemServices_DeleteClass_send;
	proxy_vtable->DeleteClassAsync_send = dcom_proxy_IWbemServices_DeleteClassAsync_send;
	proxy_vtable->CreateClassEnum_send = dcom_proxy_IWbemServices_CreateClassEnum_send;
	proxy_vtable->CreateClassEnumAsync_send = dcom_proxy_IWbemServices_CreateClassEnumAsync_send;
	proxy_vtable->PutInstance_send = dcom_proxy_IWbemServices_PutInstance_send;
	proxy_vtable->PutInstanceAsync_send = dcom_proxy_IWbemServices_PutInstanceAsync_send;
	proxy_vtable->DeleteInstance_send = dcom_proxy_IWbemServices_DeleteInstance_send;
	proxy_vtable->DeleteInstanceAsync_send = dcom_proxy_IWbemServices_DeleteInstanceAsync_send;
	proxy_vtable->CreateInstanceEnum_send = dcom_proxy_IWbemServices_CreateInstanceEnum_send;
	proxy_vtable->CreateInstanceEnumAsync_send = dcom_proxy_IWbemServices_CreateInstanceEnumAsync_send;
	proxy_vtable->ExecQuery_send = dcom_proxy_IWbemServices_ExecQuery_send;
	proxy_vtable->ExecQueryAsync_send = dcom_proxy_IWbemServices_ExecQueryAsync_send;
	proxy_vtable->ExecNotificationQuery_send = dcom_proxy_IWbemServices_ExecNotificationQuery_send;
	proxy_vtable->ExecNotificationQueryAsync_send = dcom_proxy_IWbemServices_ExecNotificationQueryAsync_send;
	proxy_vtable->ExecMethod_send = dcom_proxy_IWbemServices_ExecMethod_send;
	proxy_vtable->ExecMethodAsync_send = dcom_proxy_IWbemServices_ExecMethodAsync_send;

	proxy_vtable->iid = dcerpc_table_IWbemServices.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IEnumWbemClassObject generated by pidl */


static void dcom_proxy_IEnumWbemClassObject_Reset_recv_rpc(struct rpc_request *req);

struct IEnumWbemClassObject_Reset_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IEnumWbemClassObject_Reset_send(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct Reset *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct Reset);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IEnumWbemClassObject;
        s->opnum = DCERPC_RESET;
        s->continuation = dcom_proxy_IEnumWbemClassObject_Reset_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(Reset, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IEnumWbemClassObject_Reset_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IEnumWbemClassObject_Reset_out *out;
        struct Reset *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IEnumWbemClassObject_Reset_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(Reset, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IEnumWbemClassObject_Reset_recv(struct composite_context *c)
{
        struct IEnumWbemClassObject_Reset_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IEnumWbemClassObject_Reset(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IEnumWbemClassObject_Reset_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IEnumWbemClassObject_Reset_recv(c);
}

static void dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Next_recv_rpc(struct rpc_request *req);

struct IEnumWbemClassObject_IEnumWbemClassObject_Next_out {
	struct IWbemClassObject *apObjects;
	uint32_t puReturned;
	WERROR result;
};

static struct composite_context *dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Next_send(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, uint32_t uCount)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct IEnumWbemClassObject_Next *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct IEnumWbemClassObject_Next);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IEnumWbemClassObject;
        s->opnum = DCERPC_IENUMWBEMCLASSOBJECT_NEXT;
        s->continuation = dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Next_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.lTimeout = lTimeout;
	r->in.uCount = uCount;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(IEnumWbemClassObject_Next, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Next_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IEnumWbemClassObject_IEnumWbemClassObject_Next_out *out;
        struct IEnumWbemClassObject_Next *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_apObjects;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IEnumWbemClassObject_IEnumWbemClassObject_Next_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.apObjects = &mip_apObjects;
	r->out.puReturned = &out->puReturned;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(IEnumWbemClassObject_Next, r);
        }
	if (r->out.apObjects && *r->out.apObjects) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->apObjects, &(**r->out.apObjects).obj);
		if (*r->out.apObjects) talloc_free(*r->out.apObjects);
	} else {
		out->apObjects = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IEnumWbemClassObject_IEnumWbemClassObject_Next_recv(struct composite_context *c, struct IWbemClassObject **apObjects, uint32_t *puReturned)
{
        struct IEnumWbemClassObject_IEnumWbemClassObject_Next_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (apObjects) *apObjects = out->apObjects;
	if (puReturned) *puReturned = out->puReturned;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IEnumWbemClassObject_Next(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, uint32_t uCount, struct IWbemClassObject **apObjects, uint32_t *puReturned)
{
        struct composite_context *c;

	c = IEnumWbemClassObject_Next_send(d, mem_ctx, lTimeout, uCount);
	if (c == NULL) return WERR_NOMEM;

        return IEnumWbemClassObject_IEnumWbemClassObject_Next_recv(c, apObjects, puReturned);
}

static void dcom_proxy_IEnumWbemClassObject_NextAsync_recv_rpc(struct rpc_request *req);

struct IEnumWbemClassObject_NextAsync_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IEnumWbemClassObject_NextAsync_send(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct NextAsync *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct NextAsync);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IEnumWbemClassObject;
        s->opnum = DCERPC_NEXTASYNC;
        s->continuation = dcom_proxy_IEnumWbemClassObject_NextAsync_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(NextAsync, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IEnumWbemClassObject_NextAsync_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IEnumWbemClassObject_NextAsync_out *out;
        struct NextAsync *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IEnumWbemClassObject_NextAsync_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(NextAsync, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IEnumWbemClassObject_NextAsync_recv(struct composite_context *c)
{
        struct IEnumWbemClassObject_NextAsync_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IEnumWbemClassObject_NextAsync(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IEnumWbemClassObject_NextAsync_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IEnumWbemClassObject_NextAsync_recv(c);
}

static void dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Clone_recv_rpc(struct rpc_request *req);

struct IEnumWbemClassObject_IEnumWbemClassObject_Clone_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Clone_send(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct IEnumWbemClassObject_Clone *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct IEnumWbemClassObject_Clone);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IEnumWbemClassObject;
        s->opnum = DCERPC_IENUMWBEMCLASSOBJECT_CLONE;
        s->continuation = dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Clone_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(IEnumWbemClassObject_Clone, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Clone_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IEnumWbemClassObject_IEnumWbemClassObject_Clone_out *out;
        struct IEnumWbemClassObject_Clone *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IEnumWbemClassObject_IEnumWbemClassObject_Clone_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(IEnumWbemClassObject_Clone, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IEnumWbemClassObject_IEnumWbemClassObject_Clone_recv(struct composite_context *c)
{
        struct IEnumWbemClassObject_IEnumWbemClassObject_Clone_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IEnumWbemClassObject_Clone(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IEnumWbemClassObject_Clone_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IEnumWbemClassObject_IEnumWbemClassObject_Clone_recv(c);
}

static void dcom_proxy_IEnumWbemClassObject_Skip_recv_rpc(struct rpc_request *req);

struct IEnumWbemClassObject_Skip_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IEnumWbemClassObject_Skip_send(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct Skip *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct Skip);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IEnumWbemClassObject;
        s->opnum = DCERPC_SKIP;
        s->continuation = dcom_proxy_IEnumWbemClassObject_Skip_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(Skip, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IEnumWbemClassObject_Skip_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IEnumWbemClassObject_Skip_out *out;
        struct Skip *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IEnumWbemClassObject_Skip_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(Skip, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IEnumWbemClassObject_Skip_recv(struct composite_context *c)
{
        struct IEnumWbemClassObject_Skip_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IEnumWbemClassObject_Skip(struct IEnumWbemClassObject *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IEnumWbemClassObject_Skip_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IEnumWbemClassObject_Skip_recv(c);
}

NTSTATUS dcom_proxy_IEnumWbemClassObject_init(void)
{
	struct IEnumWbemClassObject_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IEnumWbemClassObject_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->Reset_send = dcom_proxy_IEnumWbemClassObject_Reset_send;
	proxy_vtable->IEnumWbemClassObject_Next_send = dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Next_send;
	proxy_vtable->NextAsync_send = dcom_proxy_IEnumWbemClassObject_NextAsync_send;
	proxy_vtable->IEnumWbemClassObject_Clone_send = dcom_proxy_IEnumWbemClassObject_IEnumWbemClassObject_Clone_send;
	proxy_vtable->Skip_send = dcom_proxy_IEnumWbemClassObject_Skip_send;

	proxy_vtable->iid = dcerpc_table_IEnumWbemClassObject.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IWbemLevel1Login generated by pidl */


static void dcom_proxy_IWbemLevel1Login_EstablishPosition_recv_rpc(struct rpc_request *req);

struct IWbemLevel1Login_EstablishPosition_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemLevel1Login_EstablishPosition_send(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct EstablishPosition *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct EstablishPosition);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemLevel1Login;
        s->opnum = DCERPC_ESTABLISHPOSITION;
        s->continuation = dcom_proxy_IWbemLevel1Login_EstablishPosition_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(EstablishPosition, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemLevel1Login_EstablishPosition_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemLevel1Login_EstablishPosition_out *out;
        struct EstablishPosition *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemLevel1Login_EstablishPosition_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(EstablishPosition, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemLevel1Login_EstablishPosition_recv(struct composite_context *c)
{
        struct IWbemLevel1Login_EstablishPosition_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemLevel1Login_EstablishPosition(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemLevel1Login_EstablishPosition_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemLevel1Login_EstablishPosition_recv(c);
}

static void dcom_proxy_IWbemLevel1Login_RequestChallenge_recv_rpc(struct rpc_request *req);

struct IWbemLevel1Login_RequestChallenge_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemLevel1Login_RequestChallenge_send(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct RequestChallenge *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct RequestChallenge);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemLevel1Login;
        s->opnum = DCERPC_REQUESTCHALLENGE;
        s->continuation = dcom_proxy_IWbemLevel1Login_RequestChallenge_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(RequestChallenge, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemLevel1Login_RequestChallenge_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemLevel1Login_RequestChallenge_out *out;
        struct RequestChallenge *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemLevel1Login_RequestChallenge_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(RequestChallenge, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemLevel1Login_RequestChallenge_recv(struct composite_context *c)
{
        struct IWbemLevel1Login_RequestChallenge_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemLevel1Login_RequestChallenge(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemLevel1Login_RequestChallenge_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemLevel1Login_RequestChallenge_recv(c);
}

static void dcom_proxy_IWbemLevel1Login_WBEMLogin_recv_rpc(struct rpc_request *req);

struct IWbemLevel1Login_WBEMLogin_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemLevel1Login_WBEMLogin_send(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct WBEMLogin *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct WBEMLogin);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemLevel1Login;
        s->opnum = DCERPC_WBEMLOGIN;
        s->continuation = dcom_proxy_IWbemLevel1Login_WBEMLogin_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(WBEMLogin, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemLevel1Login_WBEMLogin_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemLevel1Login_WBEMLogin_out *out;
        struct WBEMLogin *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemLevel1Login_WBEMLogin_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(WBEMLogin, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemLevel1Login_WBEMLogin_recv(struct composite_context *c)
{
        struct IWbemLevel1Login_WBEMLogin_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemLevel1Login_WBEMLogin(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c;

	c = IWbemLevel1Login_WBEMLogin_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemLevel1Login_WBEMLogin_recv(c);
}

static void dcom_proxy_IWbemLevel1Login_NTLMLogin_recv_rpc(struct rpc_request *req);

struct IWbemLevel1Login_NTLMLogin_out {
	struct IWbemServices *ppNamespace;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemLevel1Login_NTLMLogin_send(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx, const char *wszNetworkResource, const char *wszPreferredLocale, int32_t lFlags, struct IWbemContext *pCtx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct NTLMLogin *r;
	NTSTATUS status;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct NTLMLogin);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemLevel1Login;
        s->opnum = DCERPC_NTLMLOGIN;
        s->continuation = dcom_proxy_IWbemLevel1Login_NTLMLogin_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.wszNetworkResource = wszNetworkResource;
	r->in.wszPreferredLocale = wszPreferredLocale;
	r->in.lFlags = lFlags;
	if (pCtx) {
		r->in.pCtx = talloc_zero(mem_ctx, struct MInterfacePointer);
		(r->in.pCtx)->size = sizeof(struct OBJREF);
		status = dcom_OBJREF_from_IUnknown(&(*r->in.pCtx).obj, (struct IUnknown *)pCtx);
		if (!NT_STATUS_IS_OK(status)) {
			composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
			return c;
		}
	}

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(NTLMLogin, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemLevel1Login_NTLMLogin_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemLevel1Login_NTLMLogin_out *out;
        struct NTLMLogin *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_ppNamespace;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemLevel1Login_NTLMLogin_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppNamespace = &mip_ppNamespace;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(NTLMLogin, r);
        }
	if (r->out.ppNamespace && *r->out.ppNamespace) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppNamespace, &(**r->out.ppNamespace).obj);
		if (*r->out.ppNamespace) talloc_free(*r->out.ppNamespace);
	} else {
		out->ppNamespace = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemLevel1Login_NTLMLogin_recv(struct composite_context *c, struct IWbemServices **ppNamespace)
{
        struct IWbemLevel1Login_NTLMLogin_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppNamespace) *ppNamespace = out->ppNamespace;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemLevel1Login_NTLMLogin(struct IWbemLevel1Login *d, TALLOC_CTX *mem_ctx, const char *wszNetworkResource, const char *wszPreferredLocale, int32_t lFlags, struct IWbemContext *pCtx, struct IWbemServices **ppNamespace)
{
        struct composite_context *c;

	c = IWbemLevel1Login_NTLMLogin_send(d, mem_ctx, wszNetworkResource, wszPreferredLocale, lFlags, pCtx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemLevel1Login_NTLMLogin_recv(c, ppNamespace);
}

NTSTATUS dcom_proxy_IWbemLevel1Login_init(void)
{
	struct IWbemLevel1Login_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IWbemLevel1Login_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->EstablishPosition_send = dcom_proxy_IWbemLevel1Login_EstablishPosition_send;
	proxy_vtable->RequestChallenge_send = dcom_proxy_IWbemLevel1Login_RequestChallenge_send;
	proxy_vtable->WBEMLogin_send = dcom_proxy_IWbemLevel1Login_WBEMLogin_send;
	proxy_vtable->NTLMLogin_send = dcom_proxy_IWbemLevel1Login_NTLMLogin_send;

	proxy_vtable->iid = dcerpc_table_IWbemLevel1Login.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IWbemWCOSmartEnum generated by pidl */


static void dcom_proxy_IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_recv_rpc(struct rpc_request *req);

struct IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_out {
	uint32_t puReturned;
	uint32_t pSize;
	uint8_t *pData;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_send(struct IWbemWCOSmartEnum *d, TALLOC_CTX *mem_ctx, struct GUID *gEWCO, uint32_t lTimeOut, uint32_t uCount)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct IWbemWCOSmartEnum_Next *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct IWbemWCOSmartEnum_Next);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemWCOSmartEnum;
        s->opnum = DCERPC_IWBEMWCOSMARTENUM_NEXT;
        s->continuation = dcom_proxy_IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.gEWCO = gEWCO;
	r->in.lTimeOut = lTimeOut;
	r->in.uCount = uCount;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(IWbemWCOSmartEnum_Next, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_out *out;
        struct IWbemWCOSmartEnum_Next *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.puReturned = &out->puReturned;
	r->out.pSize = &out->pSize;
	r->out.pData = &out->pData;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(IWbemWCOSmartEnum_Next, r);
        }
	talloc_steal(s->mem_ctx, out->pData);
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_recv(struct composite_context *c, uint32_t *puReturned, uint32_t *pSize, uint8_t **pData)
{
        struct IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (puReturned) *puReturned = out->puReturned;
	if (pSize) *pSize = out->pSize;
	if (pData) *pData = out->pData;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemWCOSmartEnum_Next(struct IWbemWCOSmartEnum *d, TALLOC_CTX *mem_ctx, struct GUID *gEWCO, uint32_t lTimeOut, uint32_t uCount, uint32_t *puReturned, uint32_t *pSize, uint8_t **pData)
{
        struct composite_context *c;

	c = IWbemWCOSmartEnum_Next_send(d, mem_ctx, gEWCO, lTimeOut, uCount);
	if (c == NULL) return WERR_NOMEM;

        return IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_recv(c, puReturned, pSize, pData);
}

NTSTATUS dcom_proxy_IWbemWCOSmartEnum_init(void)
{
	struct IWbemWCOSmartEnum_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IWbemWCOSmartEnum_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->IWbemWCOSmartEnum_Next_send = dcom_proxy_IWbemWCOSmartEnum_IWbemWCOSmartEnum_Next_send;

	proxy_vtable->iid = dcerpc_table_IWbemWCOSmartEnum.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IWbemFetchSmartEnum generated by pidl */


static void dcom_proxy_IWbemFetchSmartEnum_Fetch_recv_rpc(struct rpc_request *req);

struct IWbemFetchSmartEnum_Fetch_out {
	struct IWbemWCOSmartEnum *ppEnum;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemFetchSmartEnum_Fetch_send(struct IWbemFetchSmartEnum *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct Fetch *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct Fetch);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemFetchSmartEnum;
        s->opnum = DCERPC_FETCH;
        s->continuation = dcom_proxy_IWbemFetchSmartEnum_Fetch_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(Fetch, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemFetchSmartEnum_Fetch_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemFetchSmartEnum_Fetch_out *out;
        struct Fetch *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_ppEnum;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemFetchSmartEnum_Fetch_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppEnum = &mip_ppEnum;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(Fetch, r);
        }
	if (r->out.ppEnum && *r->out.ppEnum) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppEnum, &(**r->out.ppEnum).obj);
		if (*r->out.ppEnum) talloc_free(*r->out.ppEnum);
	} else {
		out->ppEnum = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemFetchSmartEnum_Fetch_recv(struct composite_context *c, struct IWbemWCOSmartEnum **ppEnum)
{
        struct IWbemFetchSmartEnum_Fetch_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppEnum) *ppEnum = out->ppEnum;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemFetchSmartEnum_Fetch(struct IWbemFetchSmartEnum *d, TALLOC_CTX *mem_ctx, struct IWbemWCOSmartEnum **ppEnum)
{
        struct composite_context *c;

	c = IWbemFetchSmartEnum_Fetch_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemFetchSmartEnum_Fetch_recv(c, ppEnum);
}

static void dcom_proxy_IWbemFetchSmartEnum_Test_recv_rpc(struct rpc_request *req);

struct IWbemFetchSmartEnum_Test_out {
	struct WbemClassObject *ppEnum;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemFetchSmartEnum_Test_send(struct IWbemFetchSmartEnum *d, TALLOC_CTX *mem_ctx)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct Test *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct Test);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemFetchSmartEnum;
        s->opnum = DCERPC_TEST;
        s->continuation = dcom_proxy_IWbemFetchSmartEnum_Test_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(Test, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemFetchSmartEnum_Test_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemFetchSmartEnum_Test_out *out;
        struct Test *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemFetchSmartEnum_Test_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppEnum = &out->ppEnum;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(Test, r);
        }
	talloc_steal(s->mem_ctx, out->ppEnum);
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemFetchSmartEnum_Test_recv(struct composite_context *c, struct WbemClassObject **ppEnum)
{
        struct IWbemFetchSmartEnum_Test_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppEnum) *ppEnum = out->ppEnum;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemFetchSmartEnum_Test(struct IWbemFetchSmartEnum *d, TALLOC_CTX *mem_ctx, struct WbemClassObject **ppEnum)
{
        struct composite_context *c;

	c = IWbemFetchSmartEnum_Test_send(d, mem_ctx);
	if (c == NULL) return WERR_NOMEM;

        return IWbemFetchSmartEnum_Test_recv(c, ppEnum);
}

NTSTATUS dcom_proxy_IWbemFetchSmartEnum_init(void)
{
	struct IWbemFetchSmartEnum_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IWbemFetchSmartEnum_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->Fetch_send = dcom_proxy_IWbemFetchSmartEnum_Fetch_send;
	proxy_vtable->Test_send = dcom_proxy_IWbemFetchSmartEnum_Test_send;

	proxy_vtable->iid = dcerpc_table_IWbemFetchSmartEnum.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

/* DCOM proxy for IWbemCallResult generated by pidl */


static void dcom_proxy_IWbemCallResult_GetResultObject_recv_rpc(struct rpc_request *req);

struct IWbemCallResult_GetResultObject_out {
	struct IUnknown *ppResultObject;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemCallResult_GetResultObject_send(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct GetResultObject *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct GetResultObject);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemCallResult;
        s->opnum = DCERPC_GETRESULTOBJECT;
        s->continuation = dcom_proxy_IWbemCallResult_GetResultObject_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.lTimeout = lTimeout;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(GetResultObject, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemCallResult_GetResultObject_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemCallResult_GetResultObject_out *out;
        struct GetResultObject *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_ppResultObject;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemCallResult_GetResultObject_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppResultObject = &mip_ppResultObject;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(GetResultObject, r);
        }
	if (r->out.ppResultObject && *r->out.ppResultObject) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppResultObject, &(**r->out.ppResultObject).obj);
		if (*r->out.ppResultObject) talloc_free(*r->out.ppResultObject);
	} else {
		out->ppResultObject = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemCallResult_GetResultObject_recv(struct composite_context *c, struct IUnknown **ppResultObject)
{
        struct IWbemCallResult_GetResultObject_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppResultObject) *ppResultObject = out->ppResultObject;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemCallResult_GetResultObject(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, struct IUnknown **ppResultObject)
{
        struct composite_context *c;

	c = IWbemCallResult_GetResultObject_send(d, mem_ctx, lTimeout);
	if (c == NULL) return WERR_NOMEM;

        return IWbemCallResult_GetResultObject_recv(c, ppResultObject);
}

static void dcom_proxy_IWbemCallResult_GetResultString_recv_rpc(struct rpc_request *req);

struct IWbemCallResult_GetResultString_out {
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemCallResult_GetResultString_send(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct GetResultString *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct GetResultString);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemCallResult;
        s->opnum = DCERPC_GETRESULTSTRING;
        s->continuation = dcom_proxy_IWbemCallResult_GetResultString_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.lTimeout = lTimeout;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(GetResultString, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemCallResult_GetResultString_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemCallResult_GetResultString_out *out;
        struct GetResultString *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemCallResult_GetResultString_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(GetResultString, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemCallResult_GetResultString_recv(struct composite_context *c)
{
        struct IWbemCallResult_GetResultString_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemCallResult_GetResultString(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout)
{
        struct composite_context *c;

	c = IWbemCallResult_GetResultString_send(d, mem_ctx, lTimeout);
	if (c == NULL) return WERR_NOMEM;

        return IWbemCallResult_GetResultString_recv(c);
}

static void dcom_proxy_IWbemCallResult_GetResultServices_recv_rpc(struct rpc_request *req);

struct IWbemCallResult_GetResultServices_out {
	struct IWbemServices *ppServices;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemCallResult_GetResultServices_send(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct GetResultServices *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct GetResultServices);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemCallResult;
        s->opnum = DCERPC_GETRESULTSERVICES;
        s->continuation = dcom_proxy_IWbemCallResult_GetResultServices_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.lTimeout = lTimeout;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(GetResultServices, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemCallResult_GetResultServices_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemCallResult_GetResultServices_out *out;
        struct GetResultServices *r;
        struct ORPCTHAT that;
        NTSTATUS status;
	struct MInterfacePointer *mip_ppServices;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemCallResult_GetResultServices_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.ppServices = &mip_ppServices;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(GetResultServices, r);
        }
	if (r->out.ppServices && *r->out.ppServices) {
		status = dcom_IUnknown_from_OBJREF(s->d->ctx, (struct IUnknown **)&out->ppServices, &(**r->out.ppServices).obj);
		if (*r->out.ppServices) talloc_free(*r->out.ppServices);
	} else {
		out->ppServices = NULL;
	}
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemCallResult_GetResultServices_recv(struct composite_context *c, struct IWbemServices **ppServices)
{
        struct IWbemCallResult_GetResultServices_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (ppServices) *ppServices = out->ppServices;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemCallResult_GetResultServices(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, struct IWbemServices **ppServices)
{
        struct composite_context *c;

	c = IWbemCallResult_GetResultServices_send(d, mem_ctx, lTimeout);
	if (c == NULL) return WERR_NOMEM;

        return IWbemCallResult_GetResultServices_recv(c, ppServices);
}

static void dcom_proxy_IWbemCallResult_GetCallStatus_recv_rpc(struct rpc_request *req);

struct IWbemCallResult_GetCallStatus_out {
	int32_t plStatus;
	WERROR result;
};

static struct composite_context *dcom_proxy_IWbemCallResult_GetCallStatus_send(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout)
{
        struct composite_context *c, *c_pipe;
        struct dcom_proxy_async_call_state *s;
        struct GetCallStatus *r;

        c = composite_create(mem_ctx, d->ctx->event_ctx);
        if (c == NULL) return NULL;

        s = talloc_zero(c, struct dcom_proxy_async_call_state);
        if (composite_nomem(s, c)) return c;
        c->private_data = s;

        r = talloc_zero(s, struct GetCallStatus);
        if (composite_nomem(r, c)) return c;

        s->d = (struct IUnknown *)d;
        s->table = &dcerpc_table_IWbemCallResult;
        s->opnum = DCERPC_GETCALLSTATUS;
        s->continuation = dcom_proxy_IWbemCallResult_GetCallStatus_recv_rpc;
        s->mem_ctx = mem_ctx;
        s->r = r;

        r->in.ORPCthis.version.MajorVersion = COM_MAJOR_VERSION;
        r->in.ORPCthis.version.MinorVersion = COM_MINOR_VERSION;
        r->in.ORPCthis.cid = GUID_random();
	r->in.lTimeout = lTimeout;

        if (DEBUGLVL(12)) {
                NDR_PRINT_IN_DEBUG(GetCallStatus, r);
        }

        c_pipe = dcom_get_pipe_send((struct IUnknown *)d, mem_ctx);
        composite_continue(c, c_pipe, dcom_proxy_async_call_recv_pipe_send_rpc, c);

        return c;
}

static void dcom_proxy_IWbemCallResult_GetCallStatus_recv_rpc(struct rpc_request *req)
{
        struct composite_context *c;
        struct dcom_proxy_async_call_state *s;
        struct IWbemCallResult_GetCallStatus_out *out;
        struct GetCallStatus *r;
        struct ORPCTHAT that;
        NTSTATUS status;

        c = req->async.private;
        s = c->private_data;
        r = s->r;
        out = talloc_zero(c, struct IWbemCallResult_GetCallStatus_out);
        if (composite_nomem(out, c)) return;
        c->private_data = out;

        r->out.ORPCthat = &that;
	r->out.plStatus = &out->plStatus;

        status = dcerpc_ndr_request_recv(req);
        if (!NT_STATUS_IS_OK(status)) {
                composite_error(c, NT_STATUS_RPC_NT_CALL_FAILED);
                return;
        }

        if (DEBUGLVL(12)) {
                NDR_PRINT_OUT_DEBUG(GetCallStatus, r);
        }
	out->result = r->out.result;

        talloc_free(s);
        composite_done(c);
}

WERROR IWbemCallResult_GetCallStatus_recv(struct composite_context *c, int32_t *plStatus)
{
        struct IWbemCallResult_GetCallStatus_out *out;
        NTSTATUS status;
	WERROR result;

        status = composite_wait(c);
        if (!NT_STATUS_IS_OK(status)) {
                talloc_free(c);
                return ntstatus_to_werror(NT_STATUS_RPC_NT_CALL_FAILED);
	}
        out = c->private_data;

	if (plStatus) *plStatus = out->plStatus;
	result = out->result;

        talloc_free(c);
	return result;
}

WERROR IWbemCallResult_GetCallStatus(struct IWbemCallResult *d, TALLOC_CTX *mem_ctx, int32_t lTimeout, int32_t *plStatus)
{
        struct composite_context *c;

	c = IWbemCallResult_GetCallStatus_send(d, mem_ctx, lTimeout);
	if (c == NULL) return WERR_NOMEM;

        return IWbemCallResult_GetCallStatus_recv(c, plStatus);
}

NTSTATUS dcom_proxy_IWbemCallResult_init(void)
{
	struct IWbemCallResult_vtable *proxy_vtable = talloc(talloc_autofree_context(), struct IWbemCallResult_vtable);

	struct GUID base_iid;
	const void *base_vtable;

	base_iid = dcerpc_table_IUnknown.syntax_id.uuid;

	base_vtable = dcom_proxy_vtable_by_iid(&base_iid);
	if (base_vtable == NULL) {
		DEBUG(0, ("No proxy registered for base interface 'IUnknown'\n"));
		return NT_STATUS_FOOBAR;
	}
	
	memcpy(proxy_vtable, base_vtable, sizeof(struct IUnknown_vtable));

	proxy_vtable->GetResultObject_send = dcom_proxy_IWbemCallResult_GetResultObject_send;
	proxy_vtable->GetResultString_send = dcom_proxy_IWbemCallResult_GetResultString_send;
	proxy_vtable->GetResultServices_send = dcom_proxy_IWbemCallResult_GetResultServices_send;
	proxy_vtable->GetCallStatus_send = dcom_proxy_IWbemCallResult_GetCallStatus_send;

	proxy_vtable->iid = dcerpc_table_IWbemCallResult.syntax_id.uuid;

	return dcom_register_proxy((struct IUnknown_vtable *)proxy_vtable);
}

