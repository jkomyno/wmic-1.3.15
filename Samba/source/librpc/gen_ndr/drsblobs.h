/* header auto-generated by pidl */

#include "librpc/gen_ndr/drsuapi.h"
#ifndef _HEADER_drsblobs
#define _HEADER_drsblobs

struct replPropertyMetaData1 {
	enum drsuapi_DsAttributeId attid;
	uint32_t version;
	NTTIME orginating_time;
	struct GUID orginating_invocation_id;
	uint64_t orginating_usn;
	uint64_t local_usn;
};

struct replPropertyMetaDataCtr1 {
	uint32_t count;
	uint32_t reserved;
	struct replPropertyMetaData1 *array;
};

union replPropertyMetaDataCtr {
	struct replPropertyMetaDataCtr1 ctr1;/* [case] */
}/* [nodiscriminant] */;

struct replPropertyMetaDataBlob {
	uint32_t version;
	uint32_t reserved;
	union replPropertyMetaDataCtr ctr;/* [switch_is(version)] */
}/* [public] */;

struct replUpToDateVectorCtr1 {
	uint32_t count;
	uint32_t reserved;
	struct drsuapi_DsReplicaCoursor *coursors;
};

struct replUpToDateVectorCtr2 {
	uint32_t count;
	uint32_t reserved;
	struct drsuapi_DsReplicaCoursor2 *coursors;
};

union replUpToDateVectorCtr {
	struct replUpToDateVectorCtr1 ctr1;/* [case] */
	struct replUpToDateVectorCtr2 ctr2;/* [case(2)] */
}/* [nodiscriminant] */;

struct replUpToDateVectorBlob {
	uint32_t version;
	uint32_t reserved;
	union replUpToDateVectorCtr ctr;/* [switch_is(version)] */
}/* [public] */;

struct repsFromTo1OtherInfo {
	const char * dns_name;/* [flag(LIBNDR_FLAG_STR_ASCII|LIBNDR_FLAG_STR_SIZE4)] */
}/* [gensize,public] */;

struct repsFromTo1 {
	uint32_t blobsize;/* [value(ndr_size_repsFromTo1(r,ndr->flags)+8)] */
	uint32_t consecutive_sync_failures;
	NTTIME last_success;
	NTTIME last_attempt;
	WERROR result_last_attempt;
	struct repsFromTo1OtherInfo *other_info;/* [relative] */
	uint32_t other_info_length;/* [value(ndr_size_repsFromTo1OtherInfo(other_info,ndr->flags))] */
	uint32_t replica_flags;
	uint8_t schedule[84];
	uint32_t reserved;
	struct drsuapi_DsReplicaHighWaterMark highwatermark;
	struct GUID source_dsa_obj_guid;
	struct GUID source_dsa_invocation_id;
	struct GUID transport_guid;
}/* [gensize,public,flag(LIBNDR_PRINT_ARRAY_HEX)] */;

union repsFromTo {
	struct repsFromTo1 ctr1;/* [case] */
}/* [nodiscriminant] */;

struct repsFromToBlob {
	uint32_t version;
	uint32_t reserved;
	union repsFromTo ctr;/* [switch_is(version)] */
}/* [public] */;

struct ldapControlDirSyncExtraData {
	uint64_t h4;
	struct replUpToDateVectorCtr1 uptodateness_vector;
};

union ldapControlDirSyncExtra {
	struct ldapControlDirSyncExtraData data;/* [default] */
}/* [gensize,nodiscriminant] */;

struct ldapControlDirSyncBlob {
	uint32_t u1;/* [value(3)] */
	NTTIME time;
	uint32_t u2;
	uint32_t u3;
	uint32_t extra_length;/* [value(ndr_size_ldapControlDirSyncExtra(&r->extra,r->extra.data.uptodateness_vector.count,0))] */
	struct drsuapi_DsReplicaHighWaterMark highwatermark;
	struct GUID guid1;
	union ldapControlDirSyncExtra extra;/* [switch_is(extra_length)] */
};

struct ldapControlDirSyncCookie {
	const char *msds;/* [value("MSDS"),charset(DOS)] */
	struct ldapControlDirSyncBlob blob;/* [subcontext(0)] */
}/* [relative_base,public] */;

struct DsCompressedChunk {
	uint32_t marker;
	DATA_BLOB data;
}/* [public] */;

struct DsCompressedBlob {
	struct DsCompressedChunk chunks[5];
}/* [public] */;


struct decode_replPropertyMetaData {
	struct {
		struct replPropertyMetaDataBlob blob;
	} in;

};


struct decode_replUpToDateVector {
	struct {
		struct replUpToDateVectorBlob blob;
	} in;

};


struct decode_repsFromTo {
	struct {
		struct repsFromToBlob blob;
	} in;

};


struct decode_ldapControlDirSync {
	struct {
		struct ldapControlDirSyncCookie cookie;
	} in;

};


struct decode_DsCompressed {
	struct {
		struct DsCompressedBlob blob;
	} in;

};

#endif /* _HEADER_drsblobs */
