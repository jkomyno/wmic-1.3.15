/* This file is autogenerated by pidl. DO NOT EDIT */
%module eventlog

%{
#include "includes.h"
#include "auth/credentials/credentials.h"
#include "librpc/gen_ndr/ndr_eventlog_c.h"
#include "librpc/gen_ndr/eventlog.h"
%}
%import "samba.i"

%inline {
void ntstatus_exception(NTSTATUS status)
{
	/* FIXME */
}
}

%types(eventlog_Record);


%inline {
struct eventlog { struct dcerpc_pipe *pipe; };
}

%extend eventlog {
	eventlog (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct eventlog *ret = talloc(mem_ctx, struct eventlog);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_eventlog, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~eventlog() {
		talloc_free(self);
	}
	
	/* eventlog_ClearEventLogW */
	NTSTATUS ClearEventLogW(struct policy_handle *handle, struct lsa_String *unknown, TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_ClearEventLogW r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.handle = handle;
		r.in.unknown = unknown;
		
		status = dcerpc_eventlog_ClearEventLogW(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_BackupEventLogW */
	NTSTATUS BackupEventLogW(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_BackupEventLogW r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_BackupEventLogW(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_CloseEventLog */
	NTSTATUS CloseEventLog(struct policy_handle *handle, TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_CloseEventLog r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.handle = handle;
		
		status = dcerpc_eventlog_CloseEventLog(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*handle = *r.out.handle;
		return r.out.result;
	}
	
	/* eventlog_DeregisterEventSource */
	NTSTATUS DeregisterEventSource(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_DeregisterEventSource r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_DeregisterEventSource(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_GetNumRecords */
	NTSTATUS GetNumRecords(struct policy_handle *handle, uint32_t *number, TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_GetNumRecords r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.handle = handle;
		
		status = dcerpc_eventlog_GetNumRecords(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*number = *r.out.number;
		return r.out.result;
	}
	
	/* eventlog_GetOldestRecord */
	NTSTATUS GetOldestRecord(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_GetOldestRecord r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_GetOldestRecord(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_ChangeNotify */
	NTSTATUS ChangeNotify(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_ChangeNotify r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_ChangeNotify(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_OpenEventLogW */
	NTSTATUS OpenEventLogW(struct eventlog_OpenUnknown0 *unknown0, struct lsa_String logname, struct lsa_String servername, uint32_t unknown2, uint32_t unknown3, struct policy_handle *handle, TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_OpenEventLogW r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.unknown0 = unknown0;
		r.in.logname = logname;
		r.in.servername = servername;
		r.in.unknown2 = unknown2;
		r.in.unknown3 = unknown3;
		
		status = dcerpc_eventlog_OpenEventLogW(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*handle = *r.out.handle;
		return r.out.result;
	}
	
	/* eventlog_RegisterEventSourceW */
	NTSTATUS RegisterEventSourceW(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_RegisterEventSourceW r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_RegisterEventSourceW(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_OpenBackupEventLogW */
	NTSTATUS OpenBackupEventLogW(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_OpenBackupEventLogW r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_OpenBackupEventLogW(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_ReadEventLogW */
	NTSTATUS ReadEventLogW(struct policy_handle *handle, uint32_t flags, uint32_t offset, uint32_t number_of_bytes, uint8_t *data, uint32_t *sent_size, uint32_t *real_size, TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_ReadEventLogW r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.handle = handle;
		r.in.flags = flags;
		r.in.offset = offset;
		r.in.number_of_bytes = number_of_bytes;
		
		status = dcerpc_eventlog_ReadEventLogW(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*data = *r.out.data;
		*sent_size = *r.out.sent_size;
		*real_size = *r.out.real_size;
		return r.out.result;
	}
	
	/* eventlog_ReportEventW */
	NTSTATUS ReportEventW(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_ReportEventW r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_ReportEventW(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_ClearEventLogA */
	NTSTATUS ClearEventLogA(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_ClearEventLogA r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_ClearEventLogA(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_BackupEventLogA */
	NTSTATUS BackupEventLogA(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_BackupEventLogA r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_BackupEventLogA(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_OpenEventLogA */
	NTSTATUS OpenEventLogA(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_OpenEventLogA r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_OpenEventLogA(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_RegisterEventSourceA */
	NTSTATUS RegisterEventSourceA(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_RegisterEventSourceA r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_RegisterEventSourceA(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_OpenBackupEventLogA */
	NTSTATUS OpenBackupEventLogA(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_OpenBackupEventLogA r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_OpenBackupEventLogA(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_ReadEventLogA */
	NTSTATUS ReadEventLogA(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_ReadEventLogA r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_ReadEventLogA(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_ReportEventA */
	NTSTATUS ReportEventA(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_ReportEventA r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_ReportEventA(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_RegisterClusterSvc */
	NTSTATUS RegisterClusterSvc(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_RegisterClusterSvc r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_RegisterClusterSvc(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_DeregisterClusterSvc */
	NTSTATUS DeregisterClusterSvc(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_DeregisterClusterSvc r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_DeregisterClusterSvc(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_WriteClusterEvents */
	NTSTATUS WriteClusterEvents(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_WriteClusterEvents r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_WriteClusterEvents(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_GetLogIntormation */
	NTSTATUS GetLogIntormation(TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_GetLogIntormation r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_eventlog_GetLogIntormation(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* eventlog_FlushEventLog */
	NTSTATUS FlushEventLog(struct policy_handle *handle, TALLOC_CTX *mem_ctx = NULL)
	{
		struct eventlog_FlushEventLog r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.handle = handle;
		
		status = dcerpc_eventlog_FlushEventLog(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
};

/* eventlogReadFlags */
/* eventlogEventTypes */
/* eventlog_OpenUnknown0 */
/* eventlog_Record */

