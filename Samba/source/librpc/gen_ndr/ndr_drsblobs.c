/* parser auto-generated by pidl */

#include "includes.h"
#include "libcli/util/nterr.h"
#include "librpc/gen_ndr/ndr_misc.h"
#include "librpc/gen_ndr/ndr_dcerpc.h"
#include "librpc/rpc/dcerpc.h"
#include "librpc/gen_ndr/ndr_drsblobs.h"

#include "librpc/gen_ndr/ndr_drsuapi.h"
static NTSTATUS ndr_push_replPropertyMetaData1(struct ndr_push *ndr, int ndr_flags, const struct replPropertyMetaData1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_drsuapi_DsAttributeId(ndr, NDR_SCALARS, r->attid));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->orginating_time));
		NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->orginating_invocation_id));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->orginating_usn));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->local_usn));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_GUID(ndr, NDR_BUFFERS, &r->orginating_invocation_id));
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_replPropertyMetaData1(struct ndr_pull *ndr, int ndr_flags, struct replPropertyMetaData1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_drsuapi_DsAttributeId(ndr, NDR_SCALARS, &r->attid));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->orginating_time));
		NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->orginating_invocation_id));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->orginating_usn));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->local_usn));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_GUID(ndr, NDR_BUFFERS, &r->orginating_invocation_id));
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_replPropertyMetaData1(struct ndr_print *ndr, const char *name, const struct replPropertyMetaData1 *r)
{
	ndr_print_struct(ndr, name, "replPropertyMetaData1");
	ndr->depth++;
	ndr_print_drsuapi_DsAttributeId(ndr, "attid", r->attid);
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_NTTIME_1sec(ndr, "orginating_time", r->orginating_time);
	ndr_print_GUID(ndr, "orginating_invocation_id", &r->orginating_invocation_id);
	ndr_print_hyper(ndr, "orginating_usn", r->orginating_usn);
	ndr_print_hyper(ndr, "local_usn", r->local_usn);
	ndr->depth--;
}

static NTSTATUS ndr_push_replPropertyMetaDataCtr1(struct ndr_push *ndr, int ndr_flags, const struct replPropertyMetaDataCtr1 *r)
{
	uint32_t cntr_array_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		for (cntr_array_0 = 0; cntr_array_0 < r->count; cntr_array_0++) {
			NDR_CHECK(ndr_push_replPropertyMetaData1(ndr, NDR_SCALARS, &r->array[cntr_array_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		for (cntr_array_0 = 0; cntr_array_0 < r->count; cntr_array_0++) {
			NDR_CHECK(ndr_push_replPropertyMetaData1(ndr, NDR_BUFFERS, &r->array[cntr_array_0]));
		}
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_replPropertyMetaDataCtr1(struct ndr_pull *ndr, int ndr_flags, struct replPropertyMetaDataCtr1 *r)
{
	uint32_t cntr_array_0;
	TALLOC_CTX *_mem_save_array_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_PULL_ALLOC_N(ndr, r->array, r->count);
		_mem_save_array_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->array, 0);
		for (cntr_array_0 = 0; cntr_array_0 < r->count; cntr_array_0++) {
			NDR_CHECK(ndr_pull_replPropertyMetaData1(ndr, NDR_SCALARS, &(r->array)[cntr_array_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_array_0, 0);
	}
	if (ndr_flags & NDR_BUFFERS) {
		_mem_save_array_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->array, 0);
		for (cntr_array_0 = 0; cntr_array_0 < r->count; cntr_array_0++) {
			NDR_CHECK(ndr_pull_replPropertyMetaData1(ndr, NDR_BUFFERS, &(r->array)[cntr_array_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_array_0, 0);
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_replPropertyMetaDataCtr1(struct ndr_print *ndr, const char *name, const struct replPropertyMetaDataCtr1 *r)
{
	uint32_t cntr_array_0;
	ndr_print_struct(ndr, name, "replPropertyMetaDataCtr1");
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr->print(ndr, "%s: ARRAY(%d)", "array", r->count);
	ndr->depth++;
	for (cntr_array_0=0;cntr_array_0<r->count;cntr_array_0++) {
		char *idx_0=NULL;
		asprintf(&idx_0, "[%d]", cntr_array_0);
		if (idx_0) {
			ndr_print_replPropertyMetaData1(ndr, "array", &r->array[cntr_array_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static NTSTATUS ndr_push_replPropertyMetaDataCtr(struct ndr_push *ndr, int ndr_flags, const union replPropertyMetaDataCtr *r)
{
	int level;
	level = ndr_push_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1:
				NDR_CHECK(ndr_push_replPropertyMetaDataCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
				NDR_CHECK(ndr_push_replPropertyMetaDataCtr1(ndr, NDR_BUFFERS, &r->ctr1));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_replPropertyMetaDataCtr(struct ndr_pull *ndr, int ndr_flags, union replPropertyMetaDataCtr *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_replPropertyMetaDataCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_replPropertyMetaDataCtr1(ndr, NDR_BUFFERS, &r->ctr1));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_replPropertyMetaDataCtr(struct ndr_print *ndr, const char *name, const union replPropertyMetaDataCtr *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "replPropertyMetaDataCtr");
	switch (level) {
		case 1:
			ndr_print_replPropertyMetaDataCtr1(ndr, "ctr1", &r->ctr1);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ NTSTATUS ndr_push_replPropertyMetaDataBlob(struct ndr_push *ndr, int ndr_flags, const struct replPropertyMetaDataBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_replPropertyMetaDataCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_replPropertyMetaDataCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NT_STATUS_OK;
}

_PUBLIC_ NTSTATUS ndr_pull_replPropertyMetaDataBlob(struct ndr_pull *ndr, int ndr_flags, struct replPropertyMetaDataBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_replPropertyMetaDataCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_replPropertyMetaDataCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_replPropertyMetaDataBlob(struct ndr_print *ndr, const char *name, const struct replPropertyMetaDataBlob *r)
{
	ndr_print_struct(ndr, name, "replPropertyMetaDataBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_replPropertyMetaDataCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

static NTSTATUS ndr_push_replUpToDateVectorCtr1(struct ndr_push *ndr, int ndr_flags, const struct replUpToDateVectorCtr1 *r)
{
	uint32_t cntr_coursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		for (cntr_coursors_0 = 0; cntr_coursors_0 < r->count; cntr_coursors_0++) {
			NDR_CHECK(ndr_push_drsuapi_DsReplicaCoursor(ndr, NDR_SCALARS, &r->coursors[cntr_coursors_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		for (cntr_coursors_0 = 0; cntr_coursors_0 < r->count; cntr_coursors_0++) {
			NDR_CHECK(ndr_push_drsuapi_DsReplicaCoursor(ndr, NDR_BUFFERS, &r->coursors[cntr_coursors_0]));
		}
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_replUpToDateVectorCtr1(struct ndr_pull *ndr, int ndr_flags, struct replUpToDateVectorCtr1 *r)
{
	uint32_t cntr_coursors_0;
	TALLOC_CTX *_mem_save_coursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_PULL_ALLOC_N(ndr, r->coursors, r->count);
		_mem_save_coursors_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->coursors, 0);
		for (cntr_coursors_0 = 0; cntr_coursors_0 < r->count; cntr_coursors_0++) {
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaCoursor(ndr, NDR_SCALARS, &(r->coursors)[cntr_coursors_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_coursors_0, 0);
	}
	if (ndr_flags & NDR_BUFFERS) {
		_mem_save_coursors_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->coursors, 0);
		for (cntr_coursors_0 = 0; cntr_coursors_0 < r->count; cntr_coursors_0++) {
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaCoursor(ndr, NDR_BUFFERS, &(r->coursors)[cntr_coursors_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_coursors_0, 0);
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_replUpToDateVectorCtr1(struct ndr_print *ndr, const char *name, const struct replUpToDateVectorCtr1 *r)
{
	uint32_t cntr_coursors_0;
	ndr_print_struct(ndr, name, "replUpToDateVectorCtr1");
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr->print(ndr, "%s: ARRAY(%d)", "coursors", r->count);
	ndr->depth++;
	for (cntr_coursors_0=0;cntr_coursors_0<r->count;cntr_coursors_0++) {
		char *idx_0=NULL;
		asprintf(&idx_0, "[%d]", cntr_coursors_0);
		if (idx_0) {
			ndr_print_drsuapi_DsReplicaCoursor(ndr, "coursors", &r->coursors[cntr_coursors_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static NTSTATUS ndr_push_replUpToDateVectorCtr2(struct ndr_push *ndr, int ndr_flags, const struct replUpToDateVectorCtr2 *r)
{
	uint32_t cntr_coursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		for (cntr_coursors_0 = 0; cntr_coursors_0 < r->count; cntr_coursors_0++) {
			NDR_CHECK(ndr_push_drsuapi_DsReplicaCoursor2(ndr, NDR_SCALARS, &r->coursors[cntr_coursors_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		for (cntr_coursors_0 = 0; cntr_coursors_0 < r->count; cntr_coursors_0++) {
			NDR_CHECK(ndr_push_drsuapi_DsReplicaCoursor2(ndr, NDR_BUFFERS, &r->coursors[cntr_coursors_0]));
		}
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_replUpToDateVectorCtr2(struct ndr_pull *ndr, int ndr_flags, struct replUpToDateVectorCtr2 *r)
{
	uint32_t cntr_coursors_0;
	TALLOC_CTX *_mem_save_coursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_PULL_ALLOC_N(ndr, r->coursors, r->count);
		_mem_save_coursors_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->coursors, 0);
		for (cntr_coursors_0 = 0; cntr_coursors_0 < r->count; cntr_coursors_0++) {
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaCoursor2(ndr, NDR_SCALARS, &(r->coursors)[cntr_coursors_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_coursors_0, 0);
	}
	if (ndr_flags & NDR_BUFFERS) {
		_mem_save_coursors_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->coursors, 0);
		for (cntr_coursors_0 = 0; cntr_coursors_0 < r->count; cntr_coursors_0++) {
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaCoursor2(ndr, NDR_BUFFERS, &(r->coursors)[cntr_coursors_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_coursors_0, 0);
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_replUpToDateVectorCtr2(struct ndr_print *ndr, const char *name, const struct replUpToDateVectorCtr2 *r)
{
	uint32_t cntr_coursors_0;
	ndr_print_struct(ndr, name, "replUpToDateVectorCtr2");
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr->print(ndr, "%s: ARRAY(%d)", "coursors", r->count);
	ndr->depth++;
	for (cntr_coursors_0=0;cntr_coursors_0<r->count;cntr_coursors_0++) {
		char *idx_0=NULL;
		asprintf(&idx_0, "[%d]", cntr_coursors_0);
		if (idx_0) {
			ndr_print_drsuapi_DsReplicaCoursor2(ndr, "coursors", &r->coursors[cntr_coursors_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static NTSTATUS ndr_push_replUpToDateVectorCtr(struct ndr_push *ndr, int ndr_flags, const union replUpToDateVectorCtr *r)
{
	int level;
	level = ndr_push_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1:
				NDR_CHECK(ndr_push_replUpToDateVectorCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break;

			case 2:
				NDR_CHECK(ndr_push_replUpToDateVectorCtr2(ndr, NDR_SCALARS, &r->ctr2));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
				NDR_CHECK(ndr_push_replUpToDateVectorCtr1(ndr, NDR_BUFFERS, &r->ctr1));
			break;

			case 2:
				NDR_CHECK(ndr_push_replUpToDateVectorCtr2(ndr, NDR_BUFFERS, &r->ctr2));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_replUpToDateVectorCtr(struct ndr_pull *ndr, int ndr_flags, union replUpToDateVectorCtr *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_replUpToDateVectorCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			case 2: {
				NDR_CHECK(ndr_pull_replUpToDateVectorCtr2(ndr, NDR_SCALARS, &r->ctr2));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_replUpToDateVectorCtr1(ndr, NDR_BUFFERS, &r->ctr1));
			break; }

			case 2: {
				NDR_CHECK(ndr_pull_replUpToDateVectorCtr2(ndr, NDR_BUFFERS, &r->ctr2));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_replUpToDateVectorCtr(struct ndr_print *ndr, const char *name, const union replUpToDateVectorCtr *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "replUpToDateVectorCtr");
	switch (level) {
		case 1:
			ndr_print_replUpToDateVectorCtr1(ndr, "ctr1", &r->ctr1);
		break;

		case 2:
			ndr_print_replUpToDateVectorCtr2(ndr, "ctr2", &r->ctr2);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ NTSTATUS ndr_push_replUpToDateVectorBlob(struct ndr_push *ndr, int ndr_flags, const struct replUpToDateVectorBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_replUpToDateVectorCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_replUpToDateVectorCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NT_STATUS_OK;
}

_PUBLIC_ NTSTATUS ndr_pull_replUpToDateVectorBlob(struct ndr_pull *ndr, int ndr_flags, struct replUpToDateVectorBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_replUpToDateVectorCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_replUpToDateVectorCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_replUpToDateVectorBlob(struct ndr_print *ndr, const char *name, const struct replUpToDateVectorBlob *r)
{
	ndr_print_struct(ndr, name, "replUpToDateVectorBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_replUpToDateVectorCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

_PUBLIC_ NTSTATUS ndr_push_repsFromTo1OtherInfo(struct ndr_push *ndr, int ndr_flags, const struct repsFromTo1OtherInfo *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_ASCII|LIBNDR_FLAG_STR_SIZE4);
			NDR_CHECK(ndr_push_string(ndr, NDR_SCALARS, r->dns_name));
			ndr->flags = _flags_save_string;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ NTSTATUS ndr_pull_repsFromTo1OtherInfo(struct ndr_pull *ndr, int ndr_flags, struct repsFromTo1OtherInfo *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_ASCII|LIBNDR_FLAG_STR_SIZE4);
			NDR_CHECK(ndr_pull_string(ndr, NDR_SCALARS, &r->dns_name));
			ndr->flags = _flags_save_string;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_repsFromTo1OtherInfo(struct ndr_print *ndr, const char *name, const struct repsFromTo1OtherInfo *r)
{
	ndr_print_struct(ndr, name, "repsFromTo1OtherInfo");
	ndr->depth++;
	ndr_print_string(ndr, "dns_name", r->dns_name);
	ndr->depth--;
}

_PUBLIC_ size_t ndr_size_repsFromTo1OtherInfo(const struct repsFromTo1OtherInfo *r, int flags)
{
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_repsFromTo1OtherInfo);
}

_PUBLIC_ NTSTATUS ndr_push_repsFromTo1(struct ndr_push *ndr, int ndr_flags, const struct repsFromTo1 *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 4));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_repsFromTo1(r,ndr->flags)+8));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->consecutive_sync_failures));
			NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->last_success));
			NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->last_attempt));
			NDR_CHECK(ndr_push_WERROR(ndr, NDR_SCALARS, r->result_last_attempt));
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->other_info));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_repsFromTo1OtherInfo(r->other_info,ndr->flags)));
			NDR_CHECK(ndr_push_drsuapi_DsReplicaNeighbourFlags(ndr, NDR_SCALARS, r->replica_flags));
			NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->schedule, 84));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
			NDR_CHECK(ndr_push_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->source_dsa_obj_guid));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->source_dsa_invocation_id));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->transport_guid));
		}
		if (ndr_flags & NDR_BUFFERS) {
			if (r->other_info) {
				NDR_CHECK(ndr_push_relative_ptr2(ndr, r->other_info));
				NDR_CHECK(ndr_push_repsFromTo1OtherInfo(ndr, NDR_SCALARS, r->other_info));
			}
			NDR_CHECK(ndr_push_drsuapi_DsReplicaHighWaterMark(ndr, NDR_BUFFERS, &r->highwatermark));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_BUFFERS, &r->source_dsa_obj_guid));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_BUFFERS, &r->source_dsa_invocation_id));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_BUFFERS, &r->transport_guid));
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NT_STATUS_OK;
}

_PUBLIC_ NTSTATUS ndr_pull_repsFromTo1(struct ndr_pull *ndr, int ndr_flags, struct repsFromTo1 *r)
{
	uint32_t _ptr_other_info;
	TALLOC_CTX *_mem_save_other_info_0;
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 4));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->blobsize));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->consecutive_sync_failures));
			NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->last_success));
			NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->last_attempt));
			NDR_CHECK(ndr_pull_WERROR(ndr, NDR_SCALARS, &r->result_last_attempt));
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_other_info));
			if (_ptr_other_info) {
				NDR_PULL_ALLOC(ndr, r->other_info);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->other_info, _ptr_other_info));
			} else {
				r->other_info = NULL;
			}
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->other_info_length));
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaNeighbourFlags(ndr, NDR_SCALARS, &r->replica_flags));
			NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->schedule, 84));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->source_dsa_obj_guid));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->source_dsa_invocation_id));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->transport_guid));
		}
		if (ndr_flags & NDR_BUFFERS) {
			if (r->other_info) {
				struct ndr_pull_save _relative_save;
				ndr_pull_save(ndr, &_relative_save);
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->other_info));
				_mem_save_other_info_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->other_info, 0);
				NDR_CHECK(ndr_pull_repsFromTo1OtherInfo(ndr, NDR_SCALARS, r->other_info));
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_other_info_0, 0);
				ndr_pull_restore(ndr, &_relative_save);
			}
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaHighWaterMark(ndr, NDR_BUFFERS, &r->highwatermark));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_BUFFERS, &r->source_dsa_obj_guid));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_BUFFERS, &r->source_dsa_invocation_id));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_BUFFERS, &r->transport_guid));
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_repsFromTo1(struct ndr_print *ndr, const char *name, const struct repsFromTo1 *r)
{
	ndr_print_struct(ndr, name, "repsFromTo1");
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		ndr->depth++;
		ndr_print_uint32(ndr, "blobsize", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_repsFromTo1(r,ndr->flags)+8:r->blobsize);
		ndr_print_uint32(ndr, "consecutive_sync_failures", r->consecutive_sync_failures);
		ndr_print_NTTIME_1sec(ndr, "last_success", r->last_success);
		ndr_print_NTTIME_1sec(ndr, "last_attempt", r->last_attempt);
		ndr_print_WERROR(ndr, "result_last_attempt", r->result_last_attempt);
		ndr_print_ptr(ndr, "other_info", r->other_info);
		ndr->depth++;
		if (r->other_info) {
			ndr_print_repsFromTo1OtherInfo(ndr, "other_info", r->other_info);
		}
		ndr->depth--;
		ndr_print_uint32(ndr, "other_info_length", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_repsFromTo1OtherInfo(r->other_info,ndr->flags):r->other_info_length);
		ndr_print_drsuapi_DsReplicaNeighbourFlags(ndr, "replica_flags", r->replica_flags);
		ndr_print_array_uint8(ndr, "schedule", r->schedule, 84);
		ndr_print_uint32(ndr, "reserved", r->reserved);
		ndr_print_drsuapi_DsReplicaHighWaterMark(ndr, "highwatermark", &r->highwatermark);
		ndr_print_GUID(ndr, "source_dsa_obj_guid", &r->source_dsa_obj_guid);
		ndr_print_GUID(ndr, "source_dsa_invocation_id", &r->source_dsa_invocation_id);
		ndr_print_GUID(ndr, "transport_guid", &r->transport_guid);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

_PUBLIC_ size_t ndr_size_repsFromTo1(const struct repsFromTo1 *r, int flags)
{
	flags |= LIBNDR_PRINT_ARRAY_HEX;
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_repsFromTo1);
}

static NTSTATUS ndr_push_repsFromTo(struct ndr_push *ndr, int ndr_flags, const union repsFromTo *r)
{
	int level;
	level = ndr_push_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1:
				NDR_CHECK(ndr_push_repsFromTo1(ndr, NDR_SCALARS, &r->ctr1));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
				NDR_CHECK(ndr_push_repsFromTo1(ndr, NDR_BUFFERS, &r->ctr1));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_repsFromTo(struct ndr_pull *ndr, int ndr_flags, union repsFromTo *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_repsFromTo1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_repsFromTo1(ndr, NDR_BUFFERS, &r->ctr1));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_repsFromTo(struct ndr_print *ndr, const char *name, const union repsFromTo *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "repsFromTo");
	switch (level) {
		case 1:
			ndr_print_repsFromTo1(ndr, "ctr1", &r->ctr1);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ NTSTATUS ndr_push_repsFromToBlob(struct ndr_push *ndr, int ndr_flags, const struct repsFromToBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_repsFromTo(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_repsFromTo(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NT_STATUS_OK;
}

_PUBLIC_ NTSTATUS ndr_pull_repsFromToBlob(struct ndr_pull *ndr, int ndr_flags, struct repsFromToBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_repsFromTo(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_repsFromTo(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_repsFromToBlob(struct ndr_print *ndr, const char *name, const struct repsFromToBlob *r)
{
	ndr_print_struct(ndr, name, "repsFromToBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_repsFromTo(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

static NTSTATUS ndr_push_ldapControlDirSyncExtraData(struct ndr_push *ndr, int ndr_flags, const struct ldapControlDirSyncExtraData *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->h4));
		NDR_CHECK(ndr_push_replUpToDateVectorCtr1(ndr, NDR_SCALARS, &r->uptodateness_vector));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_replUpToDateVectorCtr1(ndr, NDR_BUFFERS, &r->uptodateness_vector));
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_ldapControlDirSyncExtraData(struct ndr_pull *ndr, int ndr_flags, struct ldapControlDirSyncExtraData *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->h4));
		NDR_CHECK(ndr_pull_replUpToDateVectorCtr1(ndr, NDR_SCALARS, &r->uptodateness_vector));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_replUpToDateVectorCtr1(ndr, NDR_BUFFERS, &r->uptodateness_vector));
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_ldapControlDirSyncExtraData(struct ndr_print *ndr, const char *name, const struct ldapControlDirSyncExtraData *r)
{
	ndr_print_struct(ndr, name, "ldapControlDirSyncExtraData");
	ndr->depth++;
	ndr_print_hyper(ndr, "h4", r->h4);
	ndr_print_replUpToDateVectorCtr1(ndr, "uptodateness_vector", &r->uptodateness_vector);
	ndr->depth--;
}

static NTSTATUS ndr_push_ldapControlDirSyncExtra(struct ndr_push *ndr, int ndr_flags, const union ldapControlDirSyncExtra *r)
{
	int level;
	level = ndr_push_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 0:
			break;

			default:
				NDR_CHECK(ndr_push_ldapControlDirSyncExtraData(ndr, NDR_SCALARS, &r->data));
			break;

		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 0:
			break;

			default:
				NDR_CHECK(ndr_push_ldapControlDirSyncExtraData(ndr, NDR_BUFFERS, &r->data));
			break;

		}
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_ldapControlDirSyncExtra(struct ndr_pull *ndr, int ndr_flags, union ldapControlDirSyncExtra *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 0: {
			break; }

			default: {
				NDR_CHECK(ndr_pull_ldapControlDirSyncExtraData(ndr, NDR_SCALARS, &r->data));
			break; }

		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 0: {
			break; }

			default: {
				NDR_CHECK(ndr_pull_ldapControlDirSyncExtraData(ndr, NDR_BUFFERS, &r->data));
			break; }

		}
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_ldapControlDirSyncExtra(struct ndr_print *ndr, const char *name, const union ldapControlDirSyncExtra *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "ldapControlDirSyncExtra");
	switch (level) {
		case 0:
		break;

		default:
			ndr_print_ldapControlDirSyncExtraData(ndr, "data", &r->data);
		break;

	}
}

static size_t ndr_size_ldapControlDirSyncExtra(const union ldapControlDirSyncExtra *r, uint32_t level, int flags)
{
	return ndr_size_union(r, flags, level, (ndr_push_flags_fn_t)ndr_push_ldapControlDirSyncExtra);
}

static NTSTATUS ndr_push_ldapControlDirSyncBlob(struct ndr_push *ndr, int ndr_flags, const struct ldapControlDirSyncBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 3));
		NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->time));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->u2));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->u3));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_ldapControlDirSyncExtra(&r->extra,r->extra.data.uptodateness_vector.count,0)));
		NDR_CHECK(ndr_push_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
		NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->guid1));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->extra, ndr_size_ldapControlDirSyncExtra(&r->extra,r->extra.data.uptodateness_vector.count,0)));
		NDR_CHECK(ndr_push_ldapControlDirSyncExtra(ndr, NDR_SCALARS, &r->extra));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_drsuapi_DsReplicaHighWaterMark(ndr, NDR_BUFFERS, &r->highwatermark));
		NDR_CHECK(ndr_push_GUID(ndr, NDR_BUFFERS, &r->guid1));
		NDR_CHECK(ndr_push_ldapControlDirSyncExtra(ndr, NDR_BUFFERS, &r->extra));
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_ldapControlDirSyncBlob(struct ndr_pull *ndr, int ndr_flags, struct ldapControlDirSyncBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->u1));
		NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->time));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->u2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->u3));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->extra_length));
		NDR_CHECK(ndr_pull_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
		NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->guid1));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->extra, r->extra_length));
		NDR_CHECK(ndr_pull_ldapControlDirSyncExtra(ndr, NDR_SCALARS, &r->extra));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_drsuapi_DsReplicaHighWaterMark(ndr, NDR_BUFFERS, &r->highwatermark));
		NDR_CHECK(ndr_pull_GUID(ndr, NDR_BUFFERS, &r->guid1));
		NDR_CHECK(ndr_pull_ldapControlDirSyncExtra(ndr, NDR_BUFFERS, &r->extra));
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_ldapControlDirSyncBlob(struct ndr_print *ndr, const char *name, const struct ldapControlDirSyncBlob *r)
{
	ndr_print_struct(ndr, name, "ldapControlDirSyncBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "u1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?3:r->u1);
	ndr_print_NTTIME(ndr, "time", r->time);
	ndr_print_uint32(ndr, "u2", r->u2);
	ndr_print_uint32(ndr, "u3", r->u3);
	ndr_print_uint32(ndr, "extra_length", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_ldapControlDirSyncExtra(&r->extra,r->extra.data.uptodateness_vector.count,0):r->extra_length);
	ndr_print_drsuapi_DsReplicaHighWaterMark(ndr, "highwatermark", &r->highwatermark);
	ndr_print_GUID(ndr, "guid1", &r->guid1);
	ndr_print_set_switch_value(ndr, &r->extra, ndr_size_ldapControlDirSyncExtra(&r->extra,r->extra.data.uptodateness_vector.count,0));
	ndr_print_ldapControlDirSyncExtra(ndr, "extra", &r->extra);
	ndr->depth--;
}

_PUBLIC_ NTSTATUS ndr_push_ldapControlDirSyncCookie(struct ndr_push *ndr, int ndr_flags, const struct ldapControlDirSyncCookie *r)
{
	uint32_t _save_relative_base_offset = ndr_push_get_relative_base_offset(ndr);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_setup_relative_base_offset1(ndr, r, ndr->offset));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, "MSDS", 4, sizeof(uint8_t), CH_DOS));
		{
			struct ndr_push *_ndr_blob;
			NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_blob, 0, -1));
			NDR_CHECK(ndr_push_ldapControlDirSyncBlob(_ndr_blob, NDR_SCALARS|NDR_BUFFERS, &r->blob));
			NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_blob, 0, -1));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_setup_relative_base_offset2(ndr, r));
	}
	ndr_push_restore_relative_base_offset(ndr, _save_relative_base_offset);
	return NT_STATUS_OK;
}

_PUBLIC_ NTSTATUS ndr_pull_ldapControlDirSyncCookie(struct ndr_pull *ndr, int ndr_flags, struct ldapControlDirSyncCookie *r)
{
	uint32_t _save_relative_base_offset = ndr_pull_get_relative_base_offset(ndr);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_setup_relative_base_offset1(ndr, r, ndr->offset));
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->msds, 4, sizeof(uint8_t), CH_DOS));
		{
			struct ndr_pull *_ndr_blob;
			NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_blob, 0, -1));
			NDR_CHECK(ndr_pull_ldapControlDirSyncBlob(_ndr_blob, NDR_SCALARS|NDR_BUFFERS, &r->blob));
			NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_blob, 0, -1));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_setup_relative_base_offset2(ndr, r));
	}
	ndr_pull_restore_relative_base_offset(ndr, _save_relative_base_offset);
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_ldapControlDirSyncCookie(struct ndr_print *ndr, const char *name, const struct ldapControlDirSyncCookie *r)
{
	ndr_print_struct(ndr, name, "ldapControlDirSyncCookie");
	ndr->depth++;
	ndr_print_string(ndr, "msds", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?"MSDS":r->msds);
	ndr_print_ldapControlDirSyncBlob(ndr, "blob", &r->blob);
	ndr->depth--;
}

_PUBLIC_ NTSTATUS ndr_push_DsCompressedChunk(struct ndr_push *ndr, int ndr_flags, const struct DsCompressedChunk *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->marker));
		NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->data));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ NTSTATUS ndr_pull_DsCompressedChunk(struct ndr_pull *ndr, int ndr_flags, struct DsCompressedChunk *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->marker));
		NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->data));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_DsCompressedChunk(struct ndr_print *ndr, const char *name, const struct DsCompressedChunk *r)
{
	ndr_print_struct(ndr, name, "DsCompressedChunk");
	ndr->depth++;
	ndr_print_uint32(ndr, "marker", r->marker);
	ndr_print_DATA_BLOB(ndr, "data", r->data);
	ndr->depth--;
}

_PUBLIC_ NTSTATUS ndr_push_DsCompressedBlob(struct ndr_push *ndr, int ndr_flags, const struct DsCompressedBlob *r)
{
	uint32_t cntr_chunks_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		for (cntr_chunks_0 = 0; cntr_chunks_0 < 5; cntr_chunks_0++) {
			NDR_CHECK(ndr_push_DsCompressedChunk(ndr, NDR_SCALARS, &r->chunks[cntr_chunks_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ NTSTATUS ndr_pull_DsCompressedBlob(struct ndr_pull *ndr, int ndr_flags, struct DsCompressedBlob *r)
{
	uint32_t cntr_chunks_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		for (cntr_chunks_0 = 0; cntr_chunks_0 < 5; cntr_chunks_0++) {
			NDR_CHECK(ndr_pull_DsCompressedChunk(ndr, NDR_SCALARS, &(r->chunks)[cntr_chunks_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_DsCompressedBlob(struct ndr_print *ndr, const char *name, const struct DsCompressedBlob *r)
{
	uint32_t cntr_chunks_0;
	ndr_print_struct(ndr, name, "DsCompressedBlob");
	ndr->depth++;
	ndr->print(ndr, "%s: ARRAY(%d)", "chunks", 5);
	ndr->depth++;
	for (cntr_chunks_0=0;cntr_chunks_0<5;cntr_chunks_0++) {
		char *idx_0=NULL;
		asprintf(&idx_0, "[%d]", cntr_chunks_0);
		if (idx_0) {
			ndr_print_DsCompressedChunk(ndr, "chunks", &r->chunks[cntr_chunks_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static NTSTATUS ndr_push_decode_replPropertyMetaData(struct ndr_push *ndr, int flags, const struct decode_replPropertyMetaData *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_replPropertyMetaDataBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_decode_replPropertyMetaData(struct ndr_pull *ndr, int flags, struct decode_replPropertyMetaData *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_replPropertyMetaDataBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_decode_replPropertyMetaData(struct ndr_print *ndr, const char *name, int flags, const struct decode_replPropertyMetaData *r)
{
	ndr_print_struct(ndr, name, "decode_replPropertyMetaData");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_replPropertyMetaData");
		ndr->depth++;
		ndr_print_replPropertyMetaDataBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_replPropertyMetaData");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static NTSTATUS ndr_push_decode_replUpToDateVector(struct ndr_push *ndr, int flags, const struct decode_replUpToDateVector *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_replUpToDateVectorBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_decode_replUpToDateVector(struct ndr_pull *ndr, int flags, struct decode_replUpToDateVector *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_replUpToDateVectorBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_decode_replUpToDateVector(struct ndr_print *ndr, const char *name, int flags, const struct decode_replUpToDateVector *r)
{
	ndr_print_struct(ndr, name, "decode_replUpToDateVector");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_replUpToDateVector");
		ndr->depth++;
		ndr_print_replUpToDateVectorBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_replUpToDateVector");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static NTSTATUS ndr_push_decode_repsFromTo(struct ndr_push *ndr, int flags, const struct decode_repsFromTo *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_repsFromToBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_decode_repsFromTo(struct ndr_pull *ndr, int flags, struct decode_repsFromTo *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_repsFromToBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_decode_repsFromTo(struct ndr_print *ndr, const char *name, int flags, const struct decode_repsFromTo *r)
{
	ndr_print_struct(ndr, name, "decode_repsFromTo");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_repsFromTo");
		ndr->depth++;
		ndr_print_repsFromToBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_repsFromTo");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static NTSTATUS ndr_push_decode_ldapControlDirSync(struct ndr_push *ndr, int flags, const struct decode_ldapControlDirSync *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_ldapControlDirSyncCookie(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.cookie));
	}
	if (flags & NDR_OUT) {
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_decode_ldapControlDirSync(struct ndr_pull *ndr, int flags, struct decode_ldapControlDirSync *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_ldapControlDirSyncCookie(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.cookie));
	}
	if (flags & NDR_OUT) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_decode_ldapControlDirSync(struct ndr_print *ndr, const char *name, int flags, const struct decode_ldapControlDirSync *r)
{
	ndr_print_struct(ndr, name, "decode_ldapControlDirSync");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_ldapControlDirSync");
		ndr->depth++;
		ndr_print_ldapControlDirSyncCookie(ndr, "cookie", &r->in.cookie);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_ldapControlDirSync");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static NTSTATUS ndr_push_decode_DsCompressed(struct ndr_push *ndr, int flags, const struct decode_DsCompressed *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_DsCompressedBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_pull_decode_DsCompressed(struct ndr_pull *ndr, int flags, struct decode_DsCompressed *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_DsCompressedBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NT_STATUS_OK;
}

_PUBLIC_ void ndr_print_decode_DsCompressed(struct ndr_print *ndr, const char *name, int flags, const struct decode_DsCompressed *r)
{
	ndr_print_struct(ndr, name, "decode_DsCompressed");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_DsCompressed");
		ndr->depth++;
		ndr_print_DsCompressedBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_DsCompressed");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static const struct dcerpc_interface_call drsblobs_calls[] = {
	{
		"decode_replPropertyMetaData",
		sizeof(struct decode_replPropertyMetaData),
		(ndr_push_flags_fn_t) ndr_push_decode_replPropertyMetaData,
		(ndr_pull_flags_fn_t) ndr_pull_decode_replPropertyMetaData,
		(ndr_print_function_t) ndr_print_decode_replPropertyMetaData,
		False,
	},
	{
		"decode_replUpToDateVector",
		sizeof(struct decode_replUpToDateVector),
		(ndr_push_flags_fn_t) ndr_push_decode_replUpToDateVector,
		(ndr_pull_flags_fn_t) ndr_pull_decode_replUpToDateVector,
		(ndr_print_function_t) ndr_print_decode_replUpToDateVector,
		False,
	},
	{
		"decode_repsFromTo",
		sizeof(struct decode_repsFromTo),
		(ndr_push_flags_fn_t) ndr_push_decode_repsFromTo,
		(ndr_pull_flags_fn_t) ndr_pull_decode_repsFromTo,
		(ndr_print_function_t) ndr_print_decode_repsFromTo,
		False,
	},
	{
		"decode_ldapControlDirSync",
		sizeof(struct decode_ldapControlDirSync),
		(ndr_push_flags_fn_t) ndr_push_decode_ldapControlDirSync,
		(ndr_pull_flags_fn_t) ndr_pull_decode_ldapControlDirSync,
		(ndr_print_function_t) ndr_print_decode_ldapControlDirSync,
		False,
	},
	{
		"decode_DsCompressed",
		sizeof(struct decode_DsCompressed),
		(ndr_push_flags_fn_t) ndr_push_decode_DsCompressed,
		(ndr_pull_flags_fn_t) ndr_pull_decode_DsCompressed,
		(ndr_print_function_t) ndr_print_decode_DsCompressed,
		False,
	},
	{ NULL, 0, NULL, NULL, NULL, False }
};

static const char * const drsblobs_endpoint_strings[] = {
	"ncacn_np:[\\pipe\\drsblobs]", 
};

static const struct dcerpc_endpoint_list drsblobs_endpoints = {
	.count	= 1,
	.names	= drsblobs_endpoint_strings
};

static const char * const drsblobs_authservice_strings[] = {
	"host", 
};

static const struct dcerpc_authservice_list drsblobs_authservices = {
	.count	= 1,
	.names	= drsblobs_authservice_strings
};


const struct dcerpc_interface_table dcerpc_table_drsblobs = {
	.name		= "drsblobs",
	.syntax_id	= {
		{0x12345778,0x1234,0xabcd,{0x00,0x01},{0x00,0x00,0x00,0x01}},
		DCERPC_DRSBLOBS_VERSION
	},
	.helpstring	= DCERPC_DRSBLOBS_HELPSTRING,
	.num_calls	= 5,
	.calls		= drsblobs_calls,
	.endpoints	= &drsblobs_endpoints,
	.authservices	= &drsblobs_authservices
};

