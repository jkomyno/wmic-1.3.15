
#include "includes.h"
#include "librpc/gen_ndr/ndr_dcom.h"
#include "rpc_server/dcerpc_server.h"
#include "rpc_server/common/common.h"

/* dcom interface stub generated by pidl */


static NTSTATUS IUnknown__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IUNKNOWN_BIND
	return DCESRV_INTERFACE_IUNKNOWN_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IUnknown__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IUNKNOWN_UNBIND
	DCESRV_INTERFACE_IUNKNOWN_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IUnknown__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IUnknown.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IUnknown.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IUnknown.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IUnknown, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IUnknown__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IUnknown_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IUnknown, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IUnknown__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IUnknown, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IUnknown__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IUnknown.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IUnknown_interface = {
	.name		= "IUnknown",
	.uuid		= "00000000-0000-0000-C000-000000000046",
	.if_version	= 0.0,
	.bind		= IUnknown__op_bind,
	.unbind		= IUnknown__op_unbind,
	.ndr_pull	= IUnknown__op_ndr_pull,
	.dispatch	= IUnknown__op_dispatch,
	.reply		= IUnknown__op_reply,
	.ndr_push	= IUnknown__op_ndr_push
};


static NTSTATUS IUnknown__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IUnknown.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IUnknown.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IUnknown_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IUnknown_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IUnknown__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IUnknown.if_version == if_version &&
		strcmp(dcerpc_table_IUnknown.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IUnknown, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IUnknown__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IUnknown.name, name)==0) {
		memcpy(iface,&dcerpc_table_IUnknown, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IUnknown_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IUnknown";

	/* fill in all the operations */
	ep_server.init_server = IUnknown__op_init_server;

	ep_server.interface_by_uuid = IUnknown__op_interface_by_uuid;
	ep_server.interface_by_name = IUnknown__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IUnknown' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IClassFactory__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ICLASSFACTORY_BIND
	return DCESRV_INTERFACE_ICLASSFACTORY_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IClassFactory__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ICLASSFACTORY_UNBIND
	DCESRV_INTERFACE_ICLASSFACTORY_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IClassFactory__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IClassFactory.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IClassFactory.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IClassFactory.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IClassFactory, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IClassFactory__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IClassFactory_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct CreateInstance *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(CreateInstance, NDR_IN, r2);
		}
		result = vtable->CreateInstance(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CreateInstance will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct RemoteCreateInstance *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(RemoteCreateInstance, NDR_IN, r2);
		}
		result = vtable->RemoteCreateInstance(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemoteCreateInstance will reply async\n"));
		}
		break;
	}
	case 5: {
		NTSTATUS result;
		struct LockServer *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(LockServer, NDR_IN, r2);
		}
		result = vtable->LockServer(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function LockServer will reply async\n"));
		}
		break;
	}
	case 6: {
		NTSTATUS result;
		struct RemoteLockServer *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(RemoteLockServer, NDR_IN, r2);
		}
		result = vtable->RemoteLockServer(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemoteLockServer will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IClassFactory, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IClassFactory__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct CreateInstance *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CreateInstance replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(CreateInstance, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in CreateInstance\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct RemoteCreateInstance *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemoteCreateInstance replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(RemoteCreateInstance, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in RemoteCreateInstance\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 5: {
		struct LockServer *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function LockServer replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(LockServer, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in LockServer\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 6: {
		struct RemoteLockServer *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemoteLockServer replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(RemoteLockServer, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in RemoteLockServer\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IClassFactory, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IClassFactory__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IClassFactory.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IClassFactory_interface = {
	.name		= "IClassFactory",
	.uuid		= "00000001-0000-0000-C000-000000000046",
	.if_version	= 0.0,
	.bind		= IClassFactory__op_bind,
	.unbind		= IClassFactory__op_unbind,
	.ndr_pull	= IClassFactory__op_ndr_pull,
	.dispatch	= IClassFactory__op_dispatch,
	.reply		= IClassFactory__op_reply,
	.ndr_push	= IClassFactory__op_ndr_push
};


static NTSTATUS IClassFactory__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IClassFactory.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IClassFactory.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IClassFactory_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IClassFactory_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IClassFactory__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IClassFactory.if_version == if_version &&
		strcmp(dcerpc_table_IClassFactory.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IClassFactory, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IClassFactory__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IClassFactory.name, name)==0) {
		memcpy(iface,&dcerpc_table_IClassFactory, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IClassFactory_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IClassFactory";

	/* fill in all the operations */
	ep_server.init_server = IClassFactory__op_init_server;

	ep_server.interface_by_uuid = IClassFactory__op_interface_by_uuid;
	ep_server.interface_by_name = IClassFactory__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IClassFactory' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IRemUnknown__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IREMUNKNOWN_BIND
	return DCESRV_INTERFACE_IREMUNKNOWN_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IRemUnknown__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IREMUNKNOWN_UNBIND
	DCESRV_INTERFACE_IREMUNKNOWN_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IRemUnknown__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IRemUnknown.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IRemUnknown.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IRemUnknown.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IRemUnknown, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IRemUnknown__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IRemUnknown_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct RemQueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(RemQueryInterface, NDR_IN, r2);
		}
		result = vtable->RemQueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemQueryInterface will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct RemAddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(RemAddRef, NDR_IN, r2);
		}
		result = vtable->RemAddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemAddRef will reply async\n"));
		}
		break;
	}
	case 5: {
		NTSTATUS result;
		struct RemRelease *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(RemRelease, NDR_IN, r2);
		}
		result = vtable->RemRelease(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemRelease will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IRemUnknown, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IRemUnknown__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct RemQueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemQueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(RemQueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in RemQueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct RemAddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemAddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(RemAddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in RemAddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 5: {
		struct RemRelease *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemRelease replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(RemRelease, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in RemRelease\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IRemUnknown, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IRemUnknown__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IRemUnknown.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IRemUnknown_interface = {
	.name		= "IRemUnknown",
	.uuid		= "00000131-0000-0000-C000-000000000046",
	.if_version	= 0.0,
	.bind		= IRemUnknown__op_bind,
	.unbind		= IRemUnknown__op_unbind,
	.ndr_pull	= IRemUnknown__op_ndr_pull,
	.dispatch	= IRemUnknown__op_dispatch,
	.reply		= IRemUnknown__op_reply,
	.ndr_push	= IRemUnknown__op_ndr_push
};


static NTSTATUS IRemUnknown__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IRemUnknown.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IRemUnknown.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IRemUnknown_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IRemUnknown_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IRemUnknown__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IRemUnknown.if_version == if_version &&
		strcmp(dcerpc_table_IRemUnknown.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IRemUnknown, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IRemUnknown__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IRemUnknown.name, name)==0) {
		memcpy(iface,&dcerpc_table_IRemUnknown, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IRemUnknown_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IRemUnknown";

	/* fill in all the operations */
	ep_server.init_server = IRemUnknown__op_init_server;

	ep_server.interface_by_uuid = IRemUnknown__op_interface_by_uuid;
	ep_server.interface_by_name = IRemUnknown__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IRemUnknown' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IClassActivator__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ICLASSACTIVATOR_BIND
	return DCESRV_INTERFACE_ICLASSACTIVATOR_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IClassActivator__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ICLASSACTIVATOR_UNBIND
	DCESRV_INTERFACE_ICLASSACTIVATOR_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IClassActivator__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IClassActivator.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IClassActivator.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IClassActivator.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IClassActivator, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IClassActivator__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IClassActivator_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		struct GetClassObject *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetClassObject, NDR_IN, r2);
		}
		vtable->GetClassObject(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetClassObject will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IClassActivator, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IClassActivator__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct GetClassObject *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetClassObject replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetClassObject, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetClassObject\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IClassActivator, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IClassActivator__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IClassActivator.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IClassActivator_interface = {
	.name		= "IClassActivator",
	.uuid		= "00000140-0000-0000-c000-000000000046",
	.if_version	= 0.0,
	.bind		= IClassActivator__op_bind,
	.unbind		= IClassActivator__op_unbind,
	.ndr_pull	= IClassActivator__op_ndr_pull,
	.dispatch	= IClassActivator__op_dispatch,
	.reply		= IClassActivator__op_reply,
	.ndr_push	= IClassActivator__op_ndr_push
};


static NTSTATUS IClassActivator__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IClassActivator.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IClassActivator.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IClassActivator_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IClassActivator_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IClassActivator__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IClassActivator.if_version == if_version &&
		strcmp(dcerpc_table_IClassActivator.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IClassActivator, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IClassActivator__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IClassActivator.name, name)==0) {
		memcpy(iface,&dcerpc_table_IClassActivator, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IClassActivator_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IClassActivator";

	/* fill in all the operations */
	ep_server.init_server = IClassActivator__op_init_server;

	ep_server.interface_by_uuid = IClassActivator__op_interface_by_uuid;
	ep_server.interface_by_name = IClassActivator__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IClassActivator' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS ISCMLocalActivator__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ISCMLOCALACTIVATOR_BIND
	return DCESRV_INTERFACE_ISCMLOCALACTIVATOR_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void ISCMLocalActivator__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ISCMLOCALACTIVATOR_UNBIND
	DCESRV_INTERFACE_ISCMLOCALACTIVATOR_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS ISCMLocalActivator__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_ISCMLocalActivator.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_ISCMLocalActivator.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_ISCMLocalActivator.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_ISCMLocalActivator, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS ISCMLocalActivator__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_ISCMLocalActivator_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		struct GetClassObject *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetClassObject, NDR_IN, r2);
		}
		vtable->GetClassObject(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetClassObject will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct ISCMLocalActivator_CreateInstance *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(ISCMLocalActivator_CreateInstance, NDR_IN, r2);
		}
		result = vtable->ISCMLocalActivator_CreateInstance(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ISCMLocalActivator_CreateInstance will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_ISCMLocalActivator, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS ISCMLocalActivator__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct GetClassObject *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetClassObject replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetClassObject, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetClassObject\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct ISCMLocalActivator_CreateInstance *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ISCMLocalActivator_CreateInstance replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(ISCMLocalActivator_CreateInstance, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in ISCMLocalActivator_CreateInstance\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_ISCMLocalActivator, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS ISCMLocalActivator__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_ISCMLocalActivator.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface ISCMLocalActivator_interface = {
	.name		= "ISCMLocalActivator",
	.uuid		= "00000136-0000-0000-c000-000000000046",
	.if_version	= 0.0,
	.bind		= ISCMLocalActivator__op_bind,
	.unbind		= ISCMLocalActivator__op_unbind,
	.ndr_pull	= ISCMLocalActivator__op_ndr_pull,
	.dispatch	= ISCMLocalActivator__op_dispatch,
	.reply		= ISCMLocalActivator__op_reply,
	.ndr_push	= ISCMLocalActivator__op_ndr_push
};


static NTSTATUS ISCMLocalActivator__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_ISCMLocalActivator.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_ISCMLocalActivator.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &ISCMLocalActivator_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("ISCMLocalActivator_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL ISCMLocalActivator__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_ISCMLocalActivator.if_version == if_version &&
		strcmp(dcerpc_table_ISCMLocalActivator.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_ISCMLocalActivator, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL ISCMLocalActivator__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_ISCMLocalActivator.name, name)==0) {
		memcpy(iface,&dcerpc_table_ISCMLocalActivator, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_ISCMLocalActivator_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "ISCMLocalActivator";

	/* fill in all the operations */
	ep_server.init_server = ISCMLocalActivator__op_init_server;

	ep_server.interface_by_uuid = ISCMLocalActivator__op_interface_by_uuid;
	ep_server.interface_by_name = ISCMLocalActivator__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'ISCMLocalActivator' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS ISystemActivator__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ISYSTEMACTIVATOR_BIND
	return DCESRV_INTERFACE_ISYSTEMACTIVATOR_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void ISystemActivator__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ISYSTEMACTIVATOR_UNBIND
	DCESRV_INTERFACE_ISYSTEMACTIVATOR_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS ISystemActivator__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_ISystemActivator.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_ISystemActivator.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_ISystemActivator.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_ISystemActivator, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS ISystemActivator__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_ISystemActivator_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		struct GetClassObject *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetClassObject, NDR_IN, r2);
		}
		vtable->GetClassObject(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetClassObject will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct ISystemActivatorRemoteCreateInstance *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(ISystemActivatorRemoteCreateInstance, NDR_IN, r2);
		}
		result = vtable->ISystemActivatorRemoteCreateInstance(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ISystemActivatorRemoteCreateInstance will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_ISystemActivator, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS ISystemActivator__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct GetClassObject *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetClassObject replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetClassObject, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetClassObject\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct ISystemActivatorRemoteCreateInstance *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ISystemActivatorRemoteCreateInstance replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(ISystemActivatorRemoteCreateInstance, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in ISystemActivatorRemoteCreateInstance\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_ISystemActivator, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS ISystemActivator__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_ISystemActivator.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface ISystemActivator_interface = {
	.name		= "ISystemActivator",
	.uuid		= "000001a0-0000-0000-c000-000000000046",
	.if_version	= 0.0,
	.bind		= ISystemActivator__op_bind,
	.unbind		= ISystemActivator__op_unbind,
	.ndr_pull	= ISystemActivator__op_ndr_pull,
	.dispatch	= ISystemActivator__op_dispatch,
	.reply		= ISystemActivator__op_reply,
	.ndr_push	= ISystemActivator__op_ndr_push
};


static NTSTATUS ISystemActivator__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_ISystemActivator.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_ISystemActivator.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &ISystemActivator_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("ISystemActivator_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL ISystemActivator__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_ISystemActivator.if_version == if_version &&
		strcmp(dcerpc_table_ISystemActivator.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_ISystemActivator, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL ISystemActivator__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_ISystemActivator.name, name)==0) {
		memcpy(iface,&dcerpc_table_ISystemActivator, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_ISystemActivator_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "ISystemActivator";

	/* fill in all the operations */
	ep_server.init_server = ISystemActivator__op_init_server;

	ep_server.interface_by_uuid = ISystemActivator__op_interface_by_uuid;
	ep_server.interface_by_name = ISystemActivator__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'ISystemActivator' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IRemUnknown2__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IREMUNKNOWN2_BIND
	return DCESRV_INTERFACE_IREMUNKNOWN2_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IRemUnknown2__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IREMUNKNOWN2_UNBIND
	DCESRV_INTERFACE_IREMUNKNOWN2_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IRemUnknown2__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IRemUnknown2.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IRemUnknown2.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IRemUnknown2.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IRemUnknown2, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IRemUnknown2__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IRemUnknown2_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct RemQueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(RemQueryInterface, NDR_IN, r2);
		}
		result = vtable->RemQueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemQueryInterface will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct RemAddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(RemAddRef, NDR_IN, r2);
		}
		result = vtable->RemAddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemAddRef will reply async\n"));
		}
		break;
	}
	case 5: {
		NTSTATUS result;
		struct RemRelease *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(RemRelease, NDR_IN, r2);
		}
		result = vtable->RemRelease(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemRelease will reply async\n"));
		}
		break;
	}
	case 6: {
		NTSTATUS result;
		struct RemQueryInterface2 *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(RemQueryInterface2, NDR_IN, r2);
		}
		result = vtable->RemQueryInterface2(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemQueryInterface2 will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IRemUnknown2, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IRemUnknown2__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct RemQueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemQueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(RemQueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in RemQueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct RemAddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemAddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(RemAddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in RemAddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 5: {
		struct RemRelease *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemRelease replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(RemRelease, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in RemRelease\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 6: {
		struct RemQueryInterface2 *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RemQueryInterface2 replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(RemQueryInterface2, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in RemQueryInterface2\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IRemUnknown2, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IRemUnknown2__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IRemUnknown2.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IRemUnknown2_interface = {
	.name		= "IRemUnknown2",
	.uuid		= "00000143-0000-0000-C000-000000000046",
	.if_version	= 0.0,
	.bind		= IRemUnknown2__op_bind,
	.unbind		= IRemUnknown2__op_unbind,
	.ndr_pull	= IRemUnknown2__op_ndr_pull,
	.dispatch	= IRemUnknown2__op_dispatch,
	.reply		= IRemUnknown2__op_reply,
	.ndr_push	= IRemUnknown2__op_ndr_push
};


static NTSTATUS IRemUnknown2__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IRemUnknown2.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IRemUnknown2.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IRemUnknown2_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IRemUnknown2_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IRemUnknown2__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IRemUnknown2.if_version == if_version &&
		strcmp(dcerpc_table_IRemUnknown2.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IRemUnknown2, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IRemUnknown2__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IRemUnknown2.name, name)==0) {
		memcpy(iface,&dcerpc_table_IRemUnknown2, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IRemUnknown2_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IRemUnknown2";

	/* fill in all the operations */
	ep_server.init_server = IRemUnknown2__op_init_server;

	ep_server.interface_by_uuid = IRemUnknown2__op_interface_by_uuid;
	ep_server.interface_by_name = IRemUnknown2__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IRemUnknown2' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IDispatch__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IDISPATCH_BIND
	return DCESRV_INTERFACE_IDISPATCH_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IDispatch__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IDISPATCH_UNBIND
	DCESRV_INTERFACE_IDISPATCH_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IDispatch__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IDispatch.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IDispatch.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IDispatch.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IDispatch, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IDispatch__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IDispatch_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct GetTypeInfoCount *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetTypeInfoCount, NDR_IN, r2);
		}
		result = vtable->GetTypeInfoCount(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetTypeInfoCount will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct GetTypeInfo *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetTypeInfo, NDR_IN, r2);
		}
		result = vtable->GetTypeInfo(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetTypeInfo will reply async\n"));
		}
		break;
	}
	case 5: {
		NTSTATUS result;
		struct GetIDsOfNames *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetIDsOfNames, NDR_IN, r2);
		}
		result = vtable->GetIDsOfNames(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetIDsOfNames will reply async\n"));
		}
		break;
	}
	case 6: {
		NTSTATUS result;
		struct Invoke *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Invoke, NDR_IN, r2);
		}
		result = vtable->Invoke(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Invoke will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IDispatch, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IDispatch__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct GetTypeInfoCount *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetTypeInfoCount replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetTypeInfoCount, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetTypeInfoCount\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct GetTypeInfo *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetTypeInfo replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetTypeInfo, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetTypeInfo\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 5: {
		struct GetIDsOfNames *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetIDsOfNames replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetIDsOfNames, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetIDsOfNames\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 6: {
		struct Invoke *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Invoke replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Invoke, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Invoke\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IDispatch, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IDispatch__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IDispatch.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IDispatch_interface = {
	.name		= "IDispatch",
	.uuid		= "00020400-0000-0000-C000-000000000046",
	.if_version	= 0.0,
	.bind		= IDispatch__op_bind,
	.unbind		= IDispatch__op_unbind,
	.ndr_pull	= IDispatch__op_ndr_pull,
	.dispatch	= IDispatch__op_dispatch,
	.reply		= IDispatch__op_reply,
	.ndr_push	= IDispatch__op_ndr_push
};


static NTSTATUS IDispatch__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IDispatch.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IDispatch.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IDispatch_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IDispatch_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IDispatch__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IDispatch.if_version == if_version &&
		strcmp(dcerpc_table_IDispatch.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IDispatch, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IDispatch__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IDispatch.name, name)==0) {
		memcpy(iface,&dcerpc_table_IDispatch, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IDispatch_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IDispatch";

	/* fill in all the operations */
	ep_server.init_server = IDispatch__op_init_server;

	ep_server.interface_by_uuid = IDispatch__op_interface_by_uuid;
	ep_server.interface_by_name = IDispatch__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IDispatch' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS ICoffeeMachine__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ICOFFEEMACHINE_BIND
	return DCESRV_INTERFACE_ICOFFEEMACHINE_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void ICoffeeMachine__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ICOFFEEMACHINE_UNBIND
	DCESRV_INTERFACE_ICOFFEEMACHINE_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS ICoffeeMachine__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_ICoffeeMachine.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_ICoffeeMachine.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_ICoffeeMachine.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_ICoffeeMachine, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS ICoffeeMachine__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_ICoffeeMachine_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct MakeCoffee *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(MakeCoffee, NDR_IN, r2);
		}
		result = vtable->MakeCoffee(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function MakeCoffee will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_ICoffeeMachine, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS ICoffeeMachine__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct MakeCoffee *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function MakeCoffee replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(MakeCoffee, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in MakeCoffee\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_ICoffeeMachine, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS ICoffeeMachine__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_ICoffeeMachine.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface ICoffeeMachine_interface = {
	.name		= "ICoffeeMachine",
	.uuid		= "DA23F6DB-6F45-466C-9EED-0B65286F2D78",
	.if_version	= 0.0,
	.bind		= ICoffeeMachine__op_bind,
	.unbind		= ICoffeeMachine__op_unbind,
	.ndr_pull	= ICoffeeMachine__op_ndr_pull,
	.dispatch	= ICoffeeMachine__op_dispatch,
	.reply		= ICoffeeMachine__op_reply,
	.ndr_push	= ICoffeeMachine__op_ndr_push
};


static NTSTATUS ICoffeeMachine__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_ICoffeeMachine.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_ICoffeeMachine.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &ICoffeeMachine_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("ICoffeeMachine_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL ICoffeeMachine__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_ICoffeeMachine.if_version == if_version &&
		strcmp(dcerpc_table_ICoffeeMachine.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_ICoffeeMachine, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL ICoffeeMachine__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_ICoffeeMachine.name, name)==0) {
		memcpy(iface,&dcerpc_table_ICoffeeMachine, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_ICoffeeMachine_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "ICoffeeMachine";

	/* fill in all the operations */
	ep_server.init_server = ICoffeeMachine__op_init_server;

	ep_server.interface_by_uuid = ICoffeeMachine__op_interface_by_uuid;
	ep_server.interface_by_name = ICoffeeMachine__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'ICoffeeMachine' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IStream__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ISTREAM_BIND
	return DCESRV_INTERFACE_ISTREAM_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IStream__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_ISTREAM_UNBIND
	DCESRV_INTERFACE_ISTREAM_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IStream__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IStream.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IStream.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IStream.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IStream, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IStream__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IStream_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct Read *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Read, NDR_IN, r2);
		}
		result = vtable->Read(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Read will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct Write *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Write, NDR_IN, r2);
		}
		result = vtable->Write(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Write will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IStream, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IStream__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct Read *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Read replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Read, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Read\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct Write *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Write replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Write, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Write\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IStream, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IStream__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IStream.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IStream_interface = {
	.name		= "IStream",
	.uuid		= "0000000C-0000-0000-C000-000000000046",
	.if_version	= 0.0,
	.bind		= IStream__op_bind,
	.unbind		= IStream__op_unbind,
	.ndr_pull	= IStream__op_ndr_pull,
	.dispatch	= IStream__op_dispatch,
	.reply		= IStream__op_reply,
	.ndr_push	= IStream__op_ndr_push
};


static NTSTATUS IStream__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IStream.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IStream.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IStream_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IStream_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IStream__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IStream.if_version == if_version &&
		strcmp(dcerpc_table_IStream.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IStream, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IStream__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IStream.name, name)==0) {
		memcpy(iface,&dcerpc_table_IStream, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IStream_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IStream";

	/* fill in all the operations */
	ep_server.init_server = IStream__op_init_server;

	ep_server.interface_by_uuid = IStream__op_interface_by_uuid;
	ep_server.interface_by_name = IStream__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IStream' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IWbemServices__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IWBEMSERVICES_BIND
	return DCESRV_INTERFACE_IWBEMSERVICES_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IWbemServices__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IWBEMSERVICES_UNBIND
	DCESRV_INTERFACE_IWBEMSERVICES_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IWbemServices__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IWbemServices.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IWbemServices.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IWbemServices.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IWbemServices, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemServices__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IWbemServices_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct OpenNamespace *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(OpenNamespace, NDR_IN, r2);
		}
		result = vtable->OpenNamespace(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function OpenNamespace will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct CancelAsyncCall *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(CancelAsyncCall, NDR_IN, r2);
		}
		result = vtable->CancelAsyncCall(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CancelAsyncCall will reply async\n"));
		}
		break;
	}
	case 5: {
		NTSTATUS result;
		struct QueryObjectSink *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryObjectSink, NDR_IN, r2);
		}
		result = vtable->QueryObjectSink(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryObjectSink will reply async\n"));
		}
		break;
	}
	case 6: {
		NTSTATUS result;
		struct GetObject *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetObject, NDR_IN, r2);
		}
		result = vtable->GetObject(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetObject will reply async\n"));
		}
		break;
	}
	case 7: {
		NTSTATUS result;
		struct GetObjectAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetObjectAsync, NDR_IN, r2);
		}
		result = vtable->GetObjectAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetObjectAsync will reply async\n"));
		}
		break;
	}
	case 8: {
		NTSTATUS result;
		struct PutClass *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(PutClass, NDR_IN, r2);
		}
		result = vtable->PutClass(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function PutClass will reply async\n"));
		}
		break;
	}
	case 9: {
		NTSTATUS result;
		struct PutClassAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(PutClassAsync, NDR_IN, r2);
		}
		result = vtable->PutClassAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function PutClassAsync will reply async\n"));
		}
		break;
	}
	case 10: {
		NTSTATUS result;
		struct DeleteClass *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(DeleteClass, NDR_IN, r2);
		}
		result = vtable->DeleteClass(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function DeleteClass will reply async\n"));
		}
		break;
	}
	case 11: {
		NTSTATUS result;
		struct DeleteClassAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(DeleteClassAsync, NDR_IN, r2);
		}
		result = vtable->DeleteClassAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function DeleteClassAsync will reply async\n"));
		}
		break;
	}
	case 12: {
		NTSTATUS result;
		struct CreateClassEnum *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(CreateClassEnum, NDR_IN, r2);
		}
		result = vtable->CreateClassEnum(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CreateClassEnum will reply async\n"));
		}
		break;
	}
	case 13: {
		NTSTATUS result;
		struct CreateClassEnumAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(CreateClassEnumAsync, NDR_IN, r2);
		}
		result = vtable->CreateClassEnumAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CreateClassEnumAsync will reply async\n"));
		}
		break;
	}
	case 14: {
		NTSTATUS result;
		struct PutInstance *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(PutInstance, NDR_IN, r2);
		}
		result = vtable->PutInstance(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function PutInstance will reply async\n"));
		}
		break;
	}
	case 15: {
		NTSTATUS result;
		struct PutInstanceAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(PutInstanceAsync, NDR_IN, r2);
		}
		result = vtable->PutInstanceAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function PutInstanceAsync will reply async\n"));
		}
		break;
	}
	case 16: {
		NTSTATUS result;
		struct DeleteInstance *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(DeleteInstance, NDR_IN, r2);
		}
		result = vtable->DeleteInstance(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function DeleteInstance will reply async\n"));
		}
		break;
	}
	case 17: {
		NTSTATUS result;
		struct DeleteInstanceAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(DeleteInstanceAsync, NDR_IN, r2);
		}
		result = vtable->DeleteInstanceAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function DeleteInstanceAsync will reply async\n"));
		}
		break;
	}
	case 18: {
		NTSTATUS result;
		struct CreateInstanceEnum *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(CreateInstanceEnum, NDR_IN, r2);
		}
		result = vtable->CreateInstanceEnum(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CreateInstanceEnum will reply async\n"));
		}
		break;
	}
	case 19: {
		NTSTATUS result;
		struct CreateInstanceEnumAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(CreateInstanceEnumAsync, NDR_IN, r2);
		}
		result = vtable->CreateInstanceEnumAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CreateInstanceEnumAsync will reply async\n"));
		}
		break;
	}
	case 20: {
		NTSTATUS result;
		struct ExecQuery *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(ExecQuery, NDR_IN, r2);
		}
		result = vtable->ExecQuery(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecQuery will reply async\n"));
		}
		break;
	}
	case 21: {
		NTSTATUS result;
		struct ExecQueryAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(ExecQueryAsync, NDR_IN, r2);
		}
		result = vtable->ExecQueryAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecQueryAsync will reply async\n"));
		}
		break;
	}
	case 22: {
		NTSTATUS result;
		struct ExecNotificationQuery *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(ExecNotificationQuery, NDR_IN, r2);
		}
		result = vtable->ExecNotificationQuery(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecNotificationQuery will reply async\n"));
		}
		break;
	}
	case 23: {
		NTSTATUS result;
		struct ExecNotificationQueryAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(ExecNotificationQueryAsync, NDR_IN, r2);
		}
		result = vtable->ExecNotificationQueryAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecNotificationQueryAsync will reply async\n"));
		}
		break;
	}
	case 24: {
		NTSTATUS result;
		struct ExecMethod *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(ExecMethod, NDR_IN, r2);
		}
		result = vtable->ExecMethod(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecMethod will reply async\n"));
		}
		break;
	}
	case 25: {
		NTSTATUS result;
		struct ExecMethodAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(ExecMethodAsync, NDR_IN, r2);
		}
		result = vtable->ExecMethodAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecMethodAsync will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IWbemServices, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemServices__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct OpenNamespace *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function OpenNamespace replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(OpenNamespace, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in OpenNamespace\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct CancelAsyncCall *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CancelAsyncCall replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(CancelAsyncCall, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in CancelAsyncCall\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 5: {
		struct QueryObjectSink *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryObjectSink replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryObjectSink, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryObjectSink\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 6: {
		struct GetObject *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetObject replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetObject, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetObject\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 7: {
		struct GetObjectAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetObjectAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetObjectAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetObjectAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 8: {
		struct PutClass *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function PutClass replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(PutClass, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in PutClass\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 9: {
		struct PutClassAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function PutClassAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(PutClassAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in PutClassAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 10: {
		struct DeleteClass *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function DeleteClass replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(DeleteClass, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in DeleteClass\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 11: {
		struct DeleteClassAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function DeleteClassAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(DeleteClassAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in DeleteClassAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 12: {
		struct CreateClassEnum *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CreateClassEnum replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(CreateClassEnum, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in CreateClassEnum\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 13: {
		struct CreateClassEnumAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CreateClassEnumAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(CreateClassEnumAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in CreateClassEnumAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 14: {
		struct PutInstance *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function PutInstance replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(PutInstance, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in PutInstance\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 15: {
		struct PutInstanceAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function PutInstanceAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(PutInstanceAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in PutInstanceAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 16: {
		struct DeleteInstance *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function DeleteInstance replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(DeleteInstance, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in DeleteInstance\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 17: {
		struct DeleteInstanceAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function DeleteInstanceAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(DeleteInstanceAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in DeleteInstanceAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 18: {
		struct CreateInstanceEnum *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CreateInstanceEnum replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(CreateInstanceEnum, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in CreateInstanceEnum\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 19: {
		struct CreateInstanceEnumAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function CreateInstanceEnumAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(CreateInstanceEnumAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in CreateInstanceEnumAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 20: {
		struct ExecQuery *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecQuery replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(ExecQuery, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in ExecQuery\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 21: {
		struct ExecQueryAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecQueryAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(ExecQueryAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in ExecQueryAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 22: {
		struct ExecNotificationQuery *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecNotificationQuery replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(ExecNotificationQuery, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in ExecNotificationQuery\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 23: {
		struct ExecNotificationQueryAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecNotificationQueryAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(ExecNotificationQueryAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in ExecNotificationQueryAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 24: {
		struct ExecMethod *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecMethod replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(ExecMethod, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in ExecMethod\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 25: {
		struct ExecMethodAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function ExecMethodAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(ExecMethodAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in ExecMethodAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IWbemServices, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemServices__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IWbemServices.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IWbemServices_interface = {
	.name		= "IWbemServices",
	.uuid		= "9556dc99-828c-11cf-a37e-00aa003240c7",
	.if_version	= 0.0,
	.bind		= IWbemServices__op_bind,
	.unbind		= IWbemServices__op_unbind,
	.ndr_pull	= IWbemServices__op_ndr_pull,
	.dispatch	= IWbemServices__op_dispatch,
	.reply		= IWbemServices__op_reply,
	.ndr_push	= IWbemServices__op_ndr_push
};


static NTSTATUS IWbemServices__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IWbemServices.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IWbemServices.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IWbemServices_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IWbemServices_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IWbemServices__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IWbemServices.if_version == if_version &&
		strcmp(dcerpc_table_IWbemServices.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IWbemServices, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IWbemServices__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IWbemServices.name, name)==0) {
		memcpy(iface,&dcerpc_table_IWbemServices, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IWbemServices_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IWbemServices";

	/* fill in all the operations */
	ep_server.init_server = IWbemServices__op_init_server;

	ep_server.interface_by_uuid = IWbemServices__op_interface_by_uuid;
	ep_server.interface_by_name = IWbemServices__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IWbemServices' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IEnumWbemClassObject__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IENUMWBEMCLASSOBJECT_BIND
	return DCESRV_INTERFACE_IENUMWBEMCLASSOBJECT_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IEnumWbemClassObject__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IENUMWBEMCLASSOBJECT_UNBIND
	DCESRV_INTERFACE_IENUMWBEMCLASSOBJECT_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IEnumWbemClassObject__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IEnumWbemClassObject.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IEnumWbemClassObject.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IEnumWbemClassObject.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IEnumWbemClassObject, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IEnumWbemClassObject__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IEnumWbemClassObject_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct Reset *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Reset, NDR_IN, r2);
		}
		result = vtable->Reset(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Reset will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct IEnumWbemClassObject_Next *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(IEnumWbemClassObject_Next, NDR_IN, r2);
		}
		result = vtable->IEnumWbemClassObject_Next(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function IEnumWbemClassObject_Next will reply async\n"));
		}
		break;
	}
	case 5: {
		NTSTATUS result;
		struct NextAsync *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(NextAsync, NDR_IN, r2);
		}
		result = vtable->NextAsync(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function NextAsync will reply async\n"));
		}
		break;
	}
	case 6: {
		NTSTATUS result;
		struct IEnumWbemClassObject_Clone *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(IEnumWbemClassObject_Clone, NDR_IN, r2);
		}
		result = vtable->IEnumWbemClassObject_Clone(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function IEnumWbemClassObject_Clone will reply async\n"));
		}
		break;
	}
	case 7: {
		NTSTATUS result;
		struct Skip *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Skip, NDR_IN, r2);
		}
		result = vtable->Skip(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Skip will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IEnumWbemClassObject, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IEnumWbemClassObject__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct Reset *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Reset replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Reset, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Reset\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct IEnumWbemClassObject_Next *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function IEnumWbemClassObject_Next replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(IEnumWbemClassObject_Next, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in IEnumWbemClassObject_Next\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 5: {
		struct NextAsync *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function NextAsync replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(NextAsync, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in NextAsync\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 6: {
		struct IEnumWbemClassObject_Clone *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function IEnumWbemClassObject_Clone replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(IEnumWbemClassObject_Clone, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in IEnumWbemClassObject_Clone\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 7: {
		struct Skip *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Skip replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Skip, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Skip\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IEnumWbemClassObject, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IEnumWbemClassObject__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IEnumWbemClassObject.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IEnumWbemClassObject_interface = {
	.name		= "IEnumWbemClassObject",
	.uuid		= "027947e1-d731-11ce-a357-000000000001",
	.if_version	= 0.0,
	.bind		= IEnumWbemClassObject__op_bind,
	.unbind		= IEnumWbemClassObject__op_unbind,
	.ndr_pull	= IEnumWbemClassObject__op_ndr_pull,
	.dispatch	= IEnumWbemClassObject__op_dispatch,
	.reply		= IEnumWbemClassObject__op_reply,
	.ndr_push	= IEnumWbemClassObject__op_ndr_push
};


static NTSTATUS IEnumWbemClassObject__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IEnumWbemClassObject.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IEnumWbemClassObject.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IEnumWbemClassObject_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IEnumWbemClassObject_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IEnumWbemClassObject__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IEnumWbemClassObject.if_version == if_version &&
		strcmp(dcerpc_table_IEnumWbemClassObject.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IEnumWbemClassObject, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IEnumWbemClassObject__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IEnumWbemClassObject.name, name)==0) {
		memcpy(iface,&dcerpc_table_IEnumWbemClassObject, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IEnumWbemClassObject_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IEnumWbemClassObject";

	/* fill in all the operations */
	ep_server.init_server = IEnumWbemClassObject__op_init_server;

	ep_server.interface_by_uuid = IEnumWbemClassObject__op_interface_by_uuid;
	ep_server.interface_by_name = IEnumWbemClassObject__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IEnumWbemClassObject' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IWbemLevel1Login__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IWBEMLEVEL1LOGIN_BIND
	return DCESRV_INTERFACE_IWBEMLEVEL1LOGIN_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IWbemLevel1Login__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IWBEMLEVEL1LOGIN_UNBIND
	DCESRV_INTERFACE_IWBEMLEVEL1LOGIN_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IWbemLevel1Login__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IWbemLevel1Login.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IWbemLevel1Login.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IWbemLevel1Login.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IWbemLevel1Login, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemLevel1Login__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IWbemLevel1Login_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct EstablishPosition *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(EstablishPosition, NDR_IN, r2);
		}
		result = vtable->EstablishPosition(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function EstablishPosition will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct RequestChallenge *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(RequestChallenge, NDR_IN, r2);
		}
		result = vtable->RequestChallenge(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RequestChallenge will reply async\n"));
		}
		break;
	}
	case 5: {
		NTSTATUS result;
		struct WBEMLogin *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(WBEMLogin, NDR_IN, r2);
		}
		result = vtable->WBEMLogin(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function WBEMLogin will reply async\n"));
		}
		break;
	}
	case 6: {
		NTSTATUS result;
		struct NTLMLogin *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(NTLMLogin, NDR_IN, r2);
		}
		result = vtable->NTLMLogin(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function NTLMLogin will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IWbemLevel1Login, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemLevel1Login__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct EstablishPosition *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function EstablishPosition replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(EstablishPosition, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in EstablishPosition\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct RequestChallenge *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function RequestChallenge replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(RequestChallenge, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in RequestChallenge\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 5: {
		struct WBEMLogin *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function WBEMLogin replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(WBEMLogin, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in WBEMLogin\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 6: {
		struct NTLMLogin *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function NTLMLogin replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(NTLMLogin, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in NTLMLogin\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IWbemLevel1Login, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemLevel1Login__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IWbemLevel1Login.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IWbemLevel1Login_interface = {
	.name		= "IWbemLevel1Login",
	.uuid		= "F309AD18-D86A-11d0-A075-00C04FB68820",
	.if_version	= 0.0,
	.bind		= IWbemLevel1Login__op_bind,
	.unbind		= IWbemLevel1Login__op_unbind,
	.ndr_pull	= IWbemLevel1Login__op_ndr_pull,
	.dispatch	= IWbemLevel1Login__op_dispatch,
	.reply		= IWbemLevel1Login__op_reply,
	.ndr_push	= IWbemLevel1Login__op_ndr_push
};


static NTSTATUS IWbemLevel1Login__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IWbemLevel1Login.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IWbemLevel1Login.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IWbemLevel1Login_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IWbemLevel1Login_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IWbemLevel1Login__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IWbemLevel1Login.if_version == if_version &&
		strcmp(dcerpc_table_IWbemLevel1Login.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IWbemLevel1Login, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IWbemLevel1Login__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IWbemLevel1Login.name, name)==0) {
		memcpy(iface,&dcerpc_table_IWbemLevel1Login, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IWbemLevel1Login_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IWbemLevel1Login";

	/* fill in all the operations */
	ep_server.init_server = IWbemLevel1Login__op_init_server;

	ep_server.interface_by_uuid = IWbemLevel1Login__op_interface_by_uuid;
	ep_server.interface_by_name = IWbemLevel1Login__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IWbemLevel1Login' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IWbemWCOSmartEnum__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IWBEMWCOSMARTENUM_BIND
	return DCESRV_INTERFACE_IWBEMWCOSMARTENUM_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IWbemWCOSmartEnum__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IWBEMWCOSMARTENUM_UNBIND
	DCESRV_INTERFACE_IWBEMWCOSMARTENUM_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IWbemWCOSmartEnum__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IWbemWCOSmartEnum.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IWbemWCOSmartEnum.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IWbemWCOSmartEnum.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IWbemWCOSmartEnum, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemWCOSmartEnum__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IWbemWCOSmartEnum_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct IWbemWCOSmartEnum_Next *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(IWbemWCOSmartEnum_Next, NDR_IN, r2);
		}
		result = vtable->IWbemWCOSmartEnum_Next(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function IWbemWCOSmartEnum_Next will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IWbemWCOSmartEnum, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemWCOSmartEnum__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct IWbemWCOSmartEnum_Next *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function IWbemWCOSmartEnum_Next replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(IWbemWCOSmartEnum_Next, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in IWbemWCOSmartEnum_Next\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IWbemWCOSmartEnum, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemWCOSmartEnum__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IWbemWCOSmartEnum.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IWbemWCOSmartEnum_interface = {
	.name		= "IWbemWCOSmartEnum",
	.uuid		= "423ec01e-2e35-11d2-b604-00104b703efd",
	.if_version	= 0.0,
	.bind		= IWbemWCOSmartEnum__op_bind,
	.unbind		= IWbemWCOSmartEnum__op_unbind,
	.ndr_pull	= IWbemWCOSmartEnum__op_ndr_pull,
	.dispatch	= IWbemWCOSmartEnum__op_dispatch,
	.reply		= IWbemWCOSmartEnum__op_reply,
	.ndr_push	= IWbemWCOSmartEnum__op_ndr_push
};


static NTSTATUS IWbemWCOSmartEnum__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IWbemWCOSmartEnum.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IWbemWCOSmartEnum.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IWbemWCOSmartEnum_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IWbemWCOSmartEnum_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IWbemWCOSmartEnum__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IWbemWCOSmartEnum.if_version == if_version &&
		strcmp(dcerpc_table_IWbemWCOSmartEnum.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IWbemWCOSmartEnum, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IWbemWCOSmartEnum__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IWbemWCOSmartEnum.name, name)==0) {
		memcpy(iface,&dcerpc_table_IWbemWCOSmartEnum, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IWbemWCOSmartEnum_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IWbemWCOSmartEnum";

	/* fill in all the operations */
	ep_server.init_server = IWbemWCOSmartEnum__op_init_server;

	ep_server.interface_by_uuid = IWbemWCOSmartEnum__op_interface_by_uuid;
	ep_server.interface_by_name = IWbemWCOSmartEnum__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IWbemWCOSmartEnum' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IWbemFetchSmartEnum__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IWBEMFETCHSMARTENUM_BIND
	return DCESRV_INTERFACE_IWBEMFETCHSMARTENUM_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IWbemFetchSmartEnum__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IWBEMFETCHSMARTENUM_UNBIND
	DCESRV_INTERFACE_IWBEMFETCHSMARTENUM_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IWbemFetchSmartEnum__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IWbemFetchSmartEnum.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IWbemFetchSmartEnum.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IWbemFetchSmartEnum.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IWbemFetchSmartEnum, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemFetchSmartEnum__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IWbemFetchSmartEnum_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct Fetch *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Fetch, NDR_IN, r2);
		}
		result = vtable->Fetch(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Fetch will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct Test *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Test, NDR_IN, r2);
		}
		result = vtable->Test(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Test will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IWbemFetchSmartEnum, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemFetchSmartEnum__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct Fetch *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Fetch replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Fetch, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Fetch\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct Test *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Test replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Test, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Test\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IWbemFetchSmartEnum, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemFetchSmartEnum__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IWbemFetchSmartEnum.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IWbemFetchSmartEnum_interface = {
	.name		= "IWbemFetchSmartEnum",
	.uuid		= "1c1c45ee-4395-11d2-b60b-00104b703efd",
	.if_version	= 0.0,
	.bind		= IWbemFetchSmartEnum__op_bind,
	.unbind		= IWbemFetchSmartEnum__op_unbind,
	.ndr_pull	= IWbemFetchSmartEnum__op_ndr_pull,
	.dispatch	= IWbemFetchSmartEnum__op_dispatch,
	.reply		= IWbemFetchSmartEnum__op_reply,
	.ndr_push	= IWbemFetchSmartEnum__op_ndr_push
};


static NTSTATUS IWbemFetchSmartEnum__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IWbemFetchSmartEnum.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IWbemFetchSmartEnum.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IWbemFetchSmartEnum_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IWbemFetchSmartEnum_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IWbemFetchSmartEnum__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IWbemFetchSmartEnum.if_version == if_version &&
		strcmp(dcerpc_table_IWbemFetchSmartEnum.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IWbemFetchSmartEnum, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IWbemFetchSmartEnum__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IWbemFetchSmartEnum.name, name)==0) {
		memcpy(iface,&dcerpc_table_IWbemFetchSmartEnum, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IWbemFetchSmartEnum_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IWbemFetchSmartEnum";

	/* fill in all the operations */
	ep_server.init_server = IWbemFetchSmartEnum__op_init_server;

	ep_server.interface_by_uuid = IWbemFetchSmartEnum__op_interface_by_uuid;
	ep_server.interface_by_name = IWbemFetchSmartEnum__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IWbemFetchSmartEnum' endpoint server!\n"));
		return ret;
	}

	return ret;
}

/* dcom interface stub generated by pidl */


static NTSTATUS IWbemCallResult__op_bind(struct dcesrv_call_state *dce_call, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IWBEMCALLRESULT_BIND
	return DCESRV_INTERFACE_IWBEMCALLRESULT_BIND(dce_call,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void IWbemCallResult__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_IWBEMCALLRESULT_UNBIND
	DCESRV_INTERFACE_IWBEMCALLRESULT_UNBIND(context, iface);
#else
	return;
#endif
}

static NTSTATUS IWbemCallResult__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= dcerpc_table_IWbemCallResult.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_size(mem_ctx, dcerpc_table_IWbemCallResult.calls[opnum].struct_size);
	NT_STATUS_HAVE_NO_MEMORY(*r);

        /* unravel the NDR for the packet */
	status = dcerpc_table_IWbemCallResult.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NT_STATUS_IS_OK(status)) {
		dcerpc_log_packet(&dcerpc_table_IWbemCallResult, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemCallResult__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct GUID ipid = dce_call->pkt.u.request.object.object;
	struct dcom_interface_p *iface = dcom_get_local_iface_p(&ipid);
	const struct dcom_IWbemCallResult_vtable *vtable = iface->vtable;

	switch (opnum) {
	case 0: {
		NTSTATUS result;
		struct QueryInterface *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_IN, r2);
		}
		result = vtable->QueryInterface(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface will reply async\n"));
		}
		break;
	}
	case 1: {
		NTSTATUS result;
		struct AddRef *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_IN, r2);
		}
		result = vtable->AddRef(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef will reply async\n"));
		}
		break;
	}
	case 2: {
		NTSTATUS result;
		struct Release *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_IN, r2);
		}
		result = vtable->Release(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release will reply async\n"));
		}
		break;
	}
	case 3: {
		NTSTATUS result;
		struct GetResultObject *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetResultObject, NDR_IN, r2);
		}
		result = vtable->GetResultObject(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetResultObject will reply async\n"));
		}
		break;
	}
	case 4: {
		NTSTATUS result;
		struct GetResultString *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetResultString, NDR_IN, r2);
		}
		result = vtable->GetResultString(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetResultString will reply async\n"));
		}
		break;
	}
	case 5: {
		NTSTATUS result;
		struct GetResultServices *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetResultServices, NDR_IN, r2);
		}
		result = vtable->GetResultServices(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetResultServices will reply async\n"));
		}
		break;
	}
	case 6: {
		NTSTATUS result;
		struct GetCallStatus *r2 = r;
		if (DEBUGLEVEL > 10) {
			NDR_PRINT_FUNCTION_DEBUG(GetCallStatus, NDR_IN, r2);
		}
		result = vtable->GetCallStatus(iface, mem_ctx, r2);
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetCallStatus will reply async\n"));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IWbemCallResult, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemCallResult__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: {
		struct QueryInterface *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function QueryInterface replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(QueryInterface, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in QueryInterface\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 1: {
		struct AddRef *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function AddRef replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(AddRef, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in AddRef\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 2: {
		struct Release *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function Release replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(Release, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in Release\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 3: {
		struct GetResultObject *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetResultObject replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetResultObject, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetResultObject\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 4: {
		struct GetResultString *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetResultString replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetResultString, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetResultString\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 5: {
		struct GetResultServices *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetResultServices replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetResultServices, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetResultServices\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}
	case 6: {
		struct GetCallStatus *r2 = r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function GetCallStatus replied async\n"));
		}
		if (DEBUGLEVEL > 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(GetCallStatus, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DEBUG(2,("dcerpc_fault %s in GetCallStatus\n", dcerpc_errstr(mem_ctx, dce_call->fault_code)));
		}
		break;
	}

	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		dcerpc_log_packet(&dcerpc_table_IWbemCallResult, opnum, NDR_IN,
				  &dce_call->pkt.u.request.stub_and_verifier);
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS IWbemCallResult__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	NTSTATUS status;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	status = dcerpc_table_IWbemCallResult.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NT_STATUS_IS_OK(status)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static const struct dcesrv_interface IWbemCallResult_interface = {
	.name		= "IWbemCallResult",
	.uuid		= "44aca675-e8fc-11d0-a07c-00c04fb68820",
	.if_version	= 0.0,
	.bind		= IWbemCallResult__op_bind,
	.unbind		= IWbemCallResult__op_unbind,
	.ndr_pull	= IWbemCallResult__op_ndr_pull,
	.dispatch	= IWbemCallResult__op_dispatch,
	.reply		= IWbemCallResult__op_reply,
	.ndr_push	= IWbemCallResult__op_ndr_push
};


static NTSTATUS IWbemCallResult__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	int i;

	for (i=0;i<dcerpc_table_IWbemCallResult.endpoints->count;i++) {
		NTSTATUS ret;
		const char *name = dcerpc_table_IWbemCallResult.endpoints->names[i];

		ret = dcesrv_interface_register(dce_ctx, name, &IWbemCallResult_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DEBUG(1,("IWbemCallResult_op_init_server: failed to register endpoint '%s'\n",name));
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static BOOL IWbemCallResult__op_interface_by_uuid(struct dcesrv_interface *iface, const char *uuid, uint32_t if_version)
{
	if (dcerpc_table_IWbemCallResult.if_version == if_version &&
		strcmp(dcerpc_table_IWbemCallResult.uuid, uuid)==0) {
		memcpy(iface,&dcerpc_table_IWbemCallResult, sizeof(*iface));
		return True;
	}

	return False;
}

static BOOL IWbemCallResult__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcerpc_table_IWbemCallResult.name, name)==0) {
		memcpy(iface,&dcerpc_table_IWbemCallResult, sizeof(*iface));
		return True;
	}

	return False;	
}
	
NTSTATUS dcerpc_server_IWbemCallResult_init(void)
{
	NTSTATUS ret;
	struct dcesrv_endpoint_server ep_server;

	/* fill in our name */
	ep_server.name = "IWbemCallResult";

	/* fill in all the operations */
	ep_server.init_server = IWbemCallResult__op_init_server;

	ep_server.interface_by_uuid = IWbemCallResult__op_interface_by_uuid;
	ep_server.interface_by_name = IWbemCallResult__op_interface_by_name;

	/* register ourselves with the DCERPC subsystem. */
	ret = dcerpc_register_ep_server(&ep_server);

	if (!NT_STATUS_IS_OK(ret)) {
		DEBUG(0,("Failed to register 'IWbemCallResult' endpoint server!\n"));
		return ret;
	}

	return ret;
}


