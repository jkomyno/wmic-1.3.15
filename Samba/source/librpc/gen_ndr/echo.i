/* This file is autogenerated by pidl. DO NOT EDIT */
%module echo

%{
#include "includes.h"
#include "auth/credentials/credentials.h"
#include "librpc/gen_ndr/ndr_echo_c.h"
#include "librpc/gen_ndr/echo.h"
%}
%import "samba.i"

%inline {
void ntstatus_exception(NTSTATUS status)
{
	/* FIXME */
}
}



%inline {
struct rpcecho { struct dcerpc_pipe *pipe; };
}

%extend rpcecho {
	rpcecho (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct rpcecho *ret = talloc(mem_ctx, struct rpcecho);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_rpcecho, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~rpcecho() {
		talloc_free(self);
	}
	
	/* echo_AddOne */
	void AddOne(uint32_t in_data, uint32_t *out_data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct echo_AddOne r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.in_data = in_data;
		
		status = dcerpc_echo_AddOne(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
		*out_data = *r.out.out_data;
	}
	
	/* echo_EchoData */
	void EchoData(uint32_t len, uint8_t *in_data, uint8_t *out_data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct echo_EchoData r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.len = len;
		r.in.in_data = in_data;
		
		status = dcerpc_echo_EchoData(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
		/* FIXME: out_data [out] argument is not a pointer */
		*out_data = *r.out.out_data;
	}
	
	/* echo_SinkData */
	void SinkData(uint32_t len, uint8_t *data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct echo_SinkData r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.len = len;
		r.in.data = data;
		
		status = dcerpc_echo_SinkData(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
	}
	
	/* echo_SourceData */
	void SourceData(uint32_t len, uint8_t *data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct echo_SourceData r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.len = len;
		
		status = dcerpc_echo_SourceData(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
		/* FIXME: data [out] argument is not a pointer */
		*data = *r.out.data;
	}
	
	/* echo_TestCall */
	void TestCall(const char *s1, const char **s2, TALLOC_CTX *mem_ctx = NULL)
	{
		struct echo_TestCall r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.s1 = s1;
		
		status = dcerpc_echo_TestCall(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
		*s2 = *r.out.s2;
	}
	
	/* echo_TestCall2 */
	NTSTATUS TestCall2(uint16_t level, union echo_Info *info, TALLOC_CTX *mem_ctx = NULL)
	{
		struct echo_TestCall2 r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.level = level;
		
		status = dcerpc_echo_TestCall2(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*info = *r.out.info;
		return r.out.result;
	}
	
	/* echo_TestSleep */
	uint32_t TestSleep(uint32_t seconds, TALLOC_CTX *mem_ctx = NULL)
	{
		struct echo_TestSleep r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.seconds = seconds;
		
		status = dcerpc_echo_TestSleep(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
	/* echo_TestEnum */
	void TestEnum(enum echo_Enum1 *foo1, struct echo_Enum2 *foo2, union echo_Enum3 *foo3, TALLOC_CTX *mem_ctx = NULL)
	{
		struct echo_TestEnum r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.foo1 = foo1;
		r.in.foo2 = foo2;
		r.in.foo3 = foo3;
		
		status = dcerpc_echo_TestEnum(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
		*foo1 = *r.out.foo1;
		*foo2 = *r.out.foo2;
		*foo3 = *r.out.foo3;
	}
	
	/* echo_TestSurrounding */
	void TestSurrounding(struct echo_Surrounding *data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct echo_TestSurrounding r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.data = data;
		
		status = dcerpc_echo_TestSurrounding(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
		*data = *r.out.data;
	}
	
	/* echo_TestDoublePointer */
	uint16_t TestDoublePointer(uint16_t ***data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct echo_TestDoublePointer r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.data = data;
		
		status = dcerpc_echo_TestDoublePointer(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
};

/* echo_info1 */
/* echo_info2 */
/* echo_info3 */
/* echo_info4 */
/* echo_info5 */
/* echo_info6 */
/* echo_info7 */
/* echo_Info */
/* echo_Enum1 */
/* echo_Enum1_32 */
/* echo_Enum2 */
/* echo_Enum3 */
/* echo_Surrounding */

