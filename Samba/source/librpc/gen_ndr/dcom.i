/* This file is autogenerated by pidl. DO NOT EDIT */
%module dcom

%{
#include "includes.h"
#include "auth/credentials/credentials.h"
#include "librpc/gen_ndr/ndr_dcom_c.h"
#include "librpc/gen_ndr/dcom.h"
%}
%import "samba.i"

%inline {
void ntstatus_exception(NTSTATUS status)
{
	/* FIXME */
}
}

%types(REMQIRESULT);
%types(WBEM_GENERIC_FLAG_TYPE);
%types(WBEM_TIMEOUT_TYPE);
%types(CIMSTRING);
%types(CIMTYPE_ENUMERATION);
%types(arr_int8);
%types(arr_uint8);
%types(arr_int16);
%types(arr_uint16);
%types(arr_int32);
%types(arr_uint32);
%types(arr_dlong);
%types(arr_udlong);
%types(arr_CIMSTRING);
%types(arr_WbemClassObject);
%types(CIMVAR);
%types(WBEM_FLAVOR_TYPE);
%types(WCO_FLAGS);
%types(WbemQualifier);
%types(WbemQualifiers);
%types(WbemPropertyDesc);
%types(WbemProperty);
%types(CIMSTRINGS);
%types(DEFAULT_FLAGS);
%types(WbemClass);
%types(WbemMethod);
%types(WbemMethods);
%types(WbemInstance);
%types(WbemClassObject);
%types(BSTR);


%inline {
struct dcom_Unknown { struct dcerpc_pipe *pipe; };
}

%extend dcom_Unknown {
	dcom_Unknown (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct dcom_Unknown *ret = talloc(mem_ctx, struct dcom_Unknown);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_dcom_Unknown, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~dcom_Unknown() {
		talloc_free(self);
	}
	
	/* UseProtSeq */
	void UseProtSeq(TALLOC_CTX *mem_ctx = NULL)
	{
		struct UseProtSeq r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_UseProtSeq(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
	}
	
	/* GetCustomProtseqInfo */
	void GetCustomProtseqInfo(TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetCustomProtseqInfo r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_GetCustomProtseqInfo(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
	}
	
	/* UpdateResolverBindings */
	void UpdateResolverBindings(TALLOC_CTX *mem_ctx = NULL)
	{
		struct UpdateResolverBindings r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_UpdateResolverBindings(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
	}
	
};


%inline {
struct IUnknown { struct dcerpc_pipe *pipe; };
}

%extend IUnknown {
	IUnknown (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IUnknown *ret = talloc(mem_ctx, struct IUnknown);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IUnknown, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IUnknown() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
};


%inline {
struct IClassFactory { struct dcerpc_pipe *pipe; };
}

%extend IClassFactory {
	IClassFactory (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IClassFactory *ret = talloc(mem_ctx, struct IClassFactory);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IClassFactory, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IClassFactory() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* CreateInstance */
	WERROR CreateInstance(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct MInterfacePointer *pUnknown, struct GUID *iid, struct MInterfacePointer **ppv, TALLOC_CTX *mem_ctx = NULL)
	{
		struct CreateInstance r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.pUnknown = pUnknown;
		r.in.iid = iid;
		
		status = dcerpc_CreateInstance(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppv = *r.out.ppv;
		return r.out.result;
	}
	
	/* RemoteCreateInstance */
	WERROR RemoteCreateInstance(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct RemoteCreateInstance r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_RemoteCreateInstance(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* LockServer */
	WERROR LockServer(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint8_t lock, TALLOC_CTX *mem_ctx = NULL)
	{
		struct LockServer r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.lock = lock;
		
		status = dcerpc_LockServer(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* RemoteLockServer */
	WERROR RemoteLockServer(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct RemoteLockServer r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_RemoteLockServer(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
};


%inline {
struct IRemUnknown { struct dcerpc_pipe *pipe; };
}

%extend IRemUnknown {
	IRemUnknown (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IRemUnknown *ret = talloc(mem_ctx, struct IRemUnknown);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IRemUnknown, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IRemUnknown() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* RemQueryInterface */
	WERROR RemQueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *ripid, uint32_t cRefs, uint16_t cIids, struct GUID *iids, struct REMQIRESULT **rqir, TALLOC_CTX *mem_ctx = NULL)
	{
		struct RemQueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.ripid = ripid;
		r.in.cRefs = cRefs;
		r.in.cIids = cIids;
		r.in.iids = iids;
		
		status = dcerpc_RemQueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*rqir = *r.out.rqir;
		return r.out.result;
	}
	
	/* RemAddRef */
	WERROR RemAddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint16_t cInterfaceRefs, struct REMINTERFACEREF *InterfaceRefs, WERROR **pResults, TALLOC_CTX *mem_ctx = NULL)
	{
		struct RemAddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.cInterfaceRefs = cInterfaceRefs;
		r.in.InterfaceRefs = InterfaceRefs;
		
		status = dcerpc_RemAddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*pResults = *r.out.pResults;
		return r.out.result;
	}
	
	/* RemRelease */
	WERROR RemRelease(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint16_t cInterfaceRefs, struct REMINTERFACEREF *InterfaceRefs, TALLOC_CTX *mem_ctx = NULL)
	{
		struct RemRelease r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.cInterfaceRefs = cInterfaceRefs;
		r.in.InterfaceRefs = InterfaceRefs;
		
		status = dcerpc_RemRelease(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
};

/* REMQIRESULT */
/* REMINTERFACEREF */

%inline {
struct IClassActivator { struct dcerpc_pipe *pipe; };
}

%extend IClassActivator {
	IClassActivator (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IClassActivator *ret = talloc(mem_ctx, struct IClassActivator);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IClassActivator, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IClassActivator() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* GetClassObject */
	void GetClassObject(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID clsid, uint32_t context, uint32_t locale, struct GUID iid, struct MInterfacePointer *data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetClassObject r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.clsid = clsid;
		r.in.context = context;
		r.in.locale = locale;
		r.in.iid = iid;
		
		status = dcerpc_GetClassObject(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
	}
	
};


%inline {
struct ISCMLocalActivator { struct dcerpc_pipe *pipe; };
}

%extend ISCMLocalActivator {
	ISCMLocalActivator (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct ISCMLocalActivator *ret = talloc(mem_ctx, struct ISCMLocalActivator);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_ISCMLocalActivator, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~ISCMLocalActivator() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* GetClassObject */
	void GetClassObject(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID clsid, uint32_t context, uint32_t locale, struct GUID iid, struct MInterfacePointer *data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetClassObject r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.clsid = clsid;
		r.in.context = context;
		r.in.locale = locale;
		r.in.iid = iid;
		
		status = dcerpc_GetClassObject(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
	}
	
	/* ISCMLocalActivator_CreateInstance */
	WERROR CreateInstance(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct ISCMLocalActivator_CreateInstance r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_ISCMLocalActivator_CreateInstance(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
};


%inline {
struct IMachineLocalActivator { struct dcerpc_pipe *pipe; };
}

%extend IMachineLocalActivator {
	IMachineLocalActivator (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IMachineLocalActivator *ret = talloc(mem_ctx, struct IMachineLocalActivator);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IMachineLocalActivator, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IMachineLocalActivator() {
		talloc_free(self);
	}
	
	/* IMachineLocalActivator_foo */
	WERROR foo(TALLOC_CTX *mem_ctx = NULL)
	{
		struct IMachineLocalActivator_foo r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_IMachineLocalActivator_foo(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
};


%inline {
struct ILocalObjectExporter { struct dcerpc_pipe *pipe; };
}

%extend ILocalObjectExporter {
	ILocalObjectExporter (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct ILocalObjectExporter *ret = talloc(mem_ctx, struct ILocalObjectExporter);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_ILocalObjectExporter, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~ILocalObjectExporter() {
		talloc_free(self);
	}
	
	/* ILocalObjectExporter_Foo */
	WERROR Foo(TALLOC_CTX *mem_ctx = NULL)
	{
		struct ILocalObjectExporter_Foo r;
		NTSTATUS status;
		
		/* Fill r structure */
		
		status = dcerpc_ILocalObjectExporter_Foo(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		return r.out.result;
	}
	
};


%inline {
struct ISystemActivator { struct dcerpc_pipe *pipe; };
}

%extend ISystemActivator {
	ISystemActivator (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct ISystemActivator *ret = talloc(mem_ctx, struct ISystemActivator);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_ISystemActivator, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~ISystemActivator() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* GetClassObject */
	void GetClassObject(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID clsid, uint32_t context, uint32_t locale, struct GUID iid, struct MInterfacePointer *data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetClassObject r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.clsid = clsid;
		r.in.context = context;
		r.in.locale = locale;
		r.in.iid = iid;
		
		status = dcerpc_GetClassObject(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
	}
	
	/* ISystemActivatorRemoteCreateInstance */
	WERROR ISystemActivatorRemoteCreateInstance(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint64_t unknown1, struct MInterfacePointer iface1, uint64_t unknown2, uint32_t *unknown3, struct MInterfacePointer *iface2, TALLOC_CTX *mem_ctx = NULL)
	{
		struct ISystemActivatorRemoteCreateInstance r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.unknown1 = unknown1;
		r.in.iface1 = iface1;
		r.in.unknown2 = unknown2;
		
		status = dcerpc_ISystemActivatorRemoteCreateInstance(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*unknown3 = *r.out.unknown3;
		*iface2 = *r.out.iface2;
		return r.out.result;
	}
	
};


%inline {
struct IRemUnknown2 { struct dcerpc_pipe *pipe; };
}

%extend IRemUnknown2 {
	IRemUnknown2 (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IRemUnknown2 *ret = talloc(mem_ctx, struct IRemUnknown2);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IRemUnknown2, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IRemUnknown2() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* RemQueryInterface */
	WERROR RemQueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *ripid, uint32_t cRefs, uint16_t cIids, struct GUID *iids, struct REMQIRESULT **rqir, TALLOC_CTX *mem_ctx = NULL)
	{
		struct RemQueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.ripid = ripid;
		r.in.cRefs = cRefs;
		r.in.cIids = cIids;
		r.in.iids = iids;
		
		status = dcerpc_RemQueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*rqir = *r.out.rqir;
		return r.out.result;
	}
	
	/* RemAddRef */
	WERROR RemAddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint16_t cInterfaceRefs, struct REMINTERFACEREF *InterfaceRefs, WERROR **pResults, TALLOC_CTX *mem_ctx = NULL)
	{
		struct RemAddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.cInterfaceRefs = cInterfaceRefs;
		r.in.InterfaceRefs = InterfaceRefs;
		
		status = dcerpc_RemAddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*pResults = *r.out.pResults;
		return r.out.result;
	}
	
	/* RemRelease */
	WERROR RemRelease(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint16_t cInterfaceRefs, struct REMINTERFACEREF *InterfaceRefs, TALLOC_CTX *mem_ctx = NULL)
	{
		struct RemRelease r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.cInterfaceRefs = cInterfaceRefs;
		r.in.InterfaceRefs = InterfaceRefs;
		
		status = dcerpc_RemRelease(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* RemQueryInterface2 */
	WERROR RemQueryInterface2(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *ripid, uint16_t cIids, struct GUID **iids, WERROR **phr, struct MInterfacePointer **ppMIF, TALLOC_CTX *mem_ctx = NULL)
	{
		struct RemQueryInterface2 r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.ripid = ripid;
		r.in.cIids = cIids;
		r.in.iids = iids;
		
		status = dcerpc_RemQueryInterface2(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*phr = *r.out.phr;
		*ppMIF = *r.out.ppMIF;
		return r.out.result;
	}
	
};


%inline {
struct IDispatch { struct dcerpc_pipe *pipe; };
}

%extend IDispatch {
	IDispatch (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IDispatch *ret = talloc(mem_ctx, struct IDispatch);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IDispatch, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IDispatch() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* GetTypeInfoCount */
	WERROR GetTypeInfoCount(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint16_t *pctinfo, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetTypeInfoCount r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_GetTypeInfoCount(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*pctinfo = *r.out.pctinfo;
		return r.out.result;
	}
	
	/* GetTypeInfo */
	WERROR GetTypeInfo(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint16_t iTInfo, uint32_t lcid, struct REF_ITypeInfo **ppTInfo, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetTypeInfo r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iTInfo = iTInfo;
		r.in.lcid = lcid;
		
		status = dcerpc_GetTypeInfo(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppTInfo = *r.out.ppTInfo;
		return r.out.result;
	}
	
	/* GetIDsOfNames */
	WERROR GetIDsOfNames(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *riid, uint16_t cNames, uint32_t lcid, uint32_t **rgDispId, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetIDsOfNames r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.riid = riid;
		r.in.cNames = cNames;
		r.in.lcid = lcid;
		
		status = dcerpc_GetIDsOfNames(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*rgDispId = *r.out.rgDispId;
		return r.out.result;
	}
	
	/* Invoke */
	WERROR Invoke(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint32_t dispIdMember, struct GUID *riid, uint32_t lcid, uint16_t wFlags, struct DISPPARAMS *pDispParams, struct VARIANT **pVarResult, struct EXCEPINFO **pExcepInfo, uint16_t **puArgErr, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Invoke r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.dispIdMember = dispIdMember;
		r.in.riid = riid;
		r.in.lcid = lcid;
		r.in.wFlags = wFlags;
		r.in.pDispParams = pDispParams;
		
		status = dcerpc_Invoke(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*pDispParams = *r.out.pDispParams;
		*pVarResult = *r.out.pVarResult;
		*pExcepInfo = *r.out.pExcepInfo;
		*puArgErr = *r.out.puArgErr;
		return r.out.result;
	}
	
};

/* REF_ITypeInfo */
/* VARIANT */
/* DISPPARAMS */
/* EXCEPINFO */

%inline {
struct IMarshal { struct dcerpc_pipe *pipe; };
}

%extend IMarshal {
	IMarshal (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IMarshal *ret = talloc(mem_ctx, struct IMarshal);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IMarshal, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IMarshal() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* MarshalInterface */
	WERROR MarshalInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct MarshalInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_MarshalInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* UnMarshalInterface */
	WERROR UnMarshalInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct UnMarshalInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_UnMarshalInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
};


%inline {
struct ICoffeeMachine { struct dcerpc_pipe *pipe; };
}

%extend ICoffeeMachine {
	ICoffeeMachine (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct ICoffeeMachine *ret = talloc(mem_ctx, struct ICoffeeMachine);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_ICoffeeMachine, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~ICoffeeMachine() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* MakeCoffee */
	WERROR MakeCoffee(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, const char *flavor, TALLOC_CTX *mem_ctx = NULL)
	{
		struct MakeCoffee r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.flavor = flavor;
		
		status = dcerpc_MakeCoffee(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
};


%inline {
struct IStream { struct dcerpc_pipe *pipe; };
}

%extend IStream {
	IStream (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IStream *ret = talloc(mem_ctx, struct IStream);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IStream, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IStream() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Read */
	WERROR Read(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint8_t *pv, uint32_t num_requested, uint32_t *num_readx, uint32_t *num_read, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Read r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.num_requested = num_requested;
		r.in.num_readx = num_readx;
		
		status = dcerpc_Read(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		/* FIXME: pv [out] argument is not a pointer */
		*pv = *r.out.pv;
		*num_read = *r.out.num_read;
		return r.out.result;
	}
	
	/* Write */
	WERROR Write(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, uint8_t *data, uint32_t num_requested, uint32_t *num_written, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Write r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.data = data;
		r.in.num_requested = num_requested;
		
		status = dcerpc_Write(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*num_written = *r.out.num_written;
		return r.out.result;
	}
	
};


%inline {
struct IWbemClassObject { struct dcerpc_pipe *pipe; };
}

%extend IWbemClassObject {
	IWbemClassObject (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IWbemClassObject *ret = talloc(mem_ctx, struct IWbemClassObject);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IWbemClassObject, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IWbemClassObject() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Delete */
	WERROR Delete(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, const char *wszName, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Delete r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.wszName = wszName;
		
		status = dcerpc_Delete(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
};


%inline {
struct IWbemServices { struct dcerpc_pipe *pipe; };
}

%extend IWbemServices {
	IWbemServices (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IWbemServices *ret = talloc(mem_ctx, struct IWbemServices);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IWbemServices, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IWbemServices() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* OpenNamespace */
	WERROR OpenNamespace(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct OpenNamespace r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_OpenNamespace(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* CancelAsyncCall */
	WERROR CancelAsyncCall(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct CancelAsyncCall r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_CancelAsyncCall(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* QueryObjectSink */
	WERROR QueryObjectSink(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryObjectSink r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_QueryObjectSink(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* GetObject */
	WERROR GetObject(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, const char strObjectPath, int32_t lFlags, struct MInterfacePointer *pCtx, struct MInterfacePointer **ppObject, struct MInterfacePointer **ppCallResult, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetObject r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.strObjectPath = strObjectPath;
		r.in.lFlags = lFlags;
		r.in.pCtx = pCtx;
		r.in.ppObject = ppObject;
		r.in.ppCallResult = ppCallResult;
		
		status = dcerpc_GetObject(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppObject = *r.out.ppObject;
		*ppCallResult = *r.out.ppCallResult;
		return r.out.result;
	}
	
	/* GetObjectAsync */
	WERROR GetObjectAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetObjectAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_GetObjectAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* PutClass */
	WERROR PutClass(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct PutClass r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_PutClass(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* PutClassAsync */
	WERROR PutClassAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct PutClassAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_PutClassAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* DeleteClass */
	WERROR DeleteClass(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct DeleteClass r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_DeleteClass(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* DeleteClassAsync */
	WERROR DeleteClassAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct DeleteClassAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_DeleteClassAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* CreateClassEnum */
	WERROR CreateClassEnum(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct CreateClassEnum r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_CreateClassEnum(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* CreateClassEnumAsync */
	WERROR CreateClassEnumAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct CreateClassEnumAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_CreateClassEnumAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* PutInstance */
	WERROR PutInstance(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct PutInstance r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_PutInstance(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* PutInstanceAsync */
	WERROR PutInstanceAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct PutInstanceAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_PutInstanceAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* DeleteInstance */
	WERROR DeleteInstance(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct DeleteInstance r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_DeleteInstance(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* DeleteInstanceAsync */
	WERROR DeleteInstanceAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct DeleteInstanceAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_DeleteInstanceAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* CreateInstanceEnum */
	WERROR CreateInstanceEnum(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, const char strFilter, int32_t lFlags, struct MInterfacePointer *pCtx, struct MInterfacePointer **ppEnum, TALLOC_CTX *mem_ctx = NULL)
	{
		struct CreateInstanceEnum r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.strFilter = strFilter;
		r.in.lFlags = lFlags;
		r.in.pCtx = pCtx;
		
		status = dcerpc_CreateInstanceEnum(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppEnum = *r.out.ppEnum;
		return r.out.result;
	}
	
	/* CreateInstanceEnumAsync */
	WERROR CreateInstanceEnumAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct CreateInstanceEnumAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_CreateInstanceEnumAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* ExecQuery */
	WERROR ExecQuery(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, const char strQueryLanguage, const char strQuery, int32_t lFlags, struct MInterfacePointer *pCtx, struct MInterfacePointer **ppEnum, TALLOC_CTX *mem_ctx = NULL)
	{
		struct ExecQuery r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.strQueryLanguage = strQueryLanguage;
		r.in.strQuery = strQuery;
		r.in.lFlags = lFlags;
		r.in.pCtx = pCtx;
		
		status = dcerpc_ExecQuery(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppEnum = *r.out.ppEnum;
		return r.out.result;
	}
	
	/* ExecQueryAsync */
	WERROR ExecQueryAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct ExecQueryAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_ExecQueryAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* ExecNotificationQuery */
	WERROR ExecNotificationQuery(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, const char strQueryLanguage, const char strQuery, int32_t lFlags, struct MInterfacePointer *pCtx, struct MInterfacePointer **ppEnum, TALLOC_CTX *mem_ctx = NULL)
	{
		struct ExecNotificationQuery r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.strQueryLanguage = strQueryLanguage;
		r.in.strQuery = strQuery;
		r.in.lFlags = lFlags;
		r.in.pCtx = pCtx;
		
		status = dcerpc_ExecNotificationQuery(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppEnum = *r.out.ppEnum;
		return r.out.result;
	}
	
	/* ExecNotificationQueryAsync */
	WERROR ExecNotificationQueryAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct ExecNotificationQueryAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_ExecNotificationQueryAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* ExecMethod */
	WERROR ExecMethod(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, const char strObjectPath, const char strMethodName, int32_t lFlags, struct MInterfacePointer *pCtx, struct MInterfacePointer *pInParams, struct MInterfacePointer **ppOutParams, struct MInterfacePointer **ppCallResult, TALLOC_CTX *mem_ctx = NULL)
	{
		struct ExecMethod r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.strObjectPath = strObjectPath;
		r.in.strMethodName = strMethodName;
		r.in.lFlags = lFlags;
		r.in.pCtx = pCtx;
		r.in.pInParams = pInParams;
		r.in.ppOutParams = ppOutParams;
		r.in.ppCallResult = ppCallResult;
		
		status = dcerpc_ExecMethod(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppOutParams = *r.out.ppOutParams;
		*ppCallResult = *r.out.ppCallResult;
		return r.out.result;
	}
	
	/* ExecMethodAsync */
	WERROR ExecMethodAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct ExecMethodAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_ExecMethodAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
};

/* WBEMSTATUS */
/* WBEM_GENERIC_FLAG_TYPE */
/* WBEM_TIMEOUT_TYPE */
/* CIMSTRING */
/* CIMTYPE_ENUMERATION */
/* arr_int8 */
/* arr_uint8 */
/* arr_int16 */
/* arr_uint16 */
/* arr_int32 */
/* arr_uint32 */
/* arr_dlong */
/* arr_udlong */
/* arr_CIMSTRING */
/* arr_WbemClassObject */
/* CIMVAR */
/* WBEM_FLAVOR_TYPE */
/* WCO_FLAGS */
/* WbemQualifier */
/* WbemQualifiers */
/* WbemPropertyDesc */
/* WbemProperty */
/* CIMSTRINGS */
/* DEFAULT_FLAGS */
/* WbemClass */
/* WbemMethod */
/* WbemMethods */
/* WbemInstance */
/* WbemClassObject */
/* BSTR */

%inline {
struct IEnumWbemClassObject { struct dcerpc_pipe *pipe; };
}

%extend IEnumWbemClassObject {
	IEnumWbemClassObject (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IEnumWbemClassObject *ret = talloc(mem_ctx, struct IEnumWbemClassObject);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IEnumWbemClassObject, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IEnumWbemClassObject() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Reset */
	WERROR Reset(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Reset r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Reset(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* IEnumWbemClassObject_Next */
	WERROR Next(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, int32_t lTimeout, uint32_t uCount, struct MInterfacePointer **apObjects, uint32_t *puReturned, TALLOC_CTX *mem_ctx = NULL)
	{
		struct IEnumWbemClassObject_Next r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.lTimeout = lTimeout;
		r.in.uCount = uCount;
		
		status = dcerpc_IEnumWbemClassObject_Next(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*apObjects = *r.out.apObjects;
		*puReturned = *r.out.puReturned;
		return r.out.result;
	}
	
	/* NextAsync */
	WERROR NextAsync(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct NextAsync r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_NextAsync(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* IEnumWbemClassObject_Clone */
	WERROR Clone(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct IEnumWbemClassObject_Clone r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_IEnumWbemClassObject_Clone(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Skip */
	WERROR Skip(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Skip r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Skip(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
};


%inline {
struct IWbemContext { struct dcerpc_pipe *pipe; };
}

%extend IWbemContext {
	IWbemContext (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IWbemContext *ret = talloc(mem_ctx, struct IWbemContext);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IWbemContext, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IWbemContext() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Clone */
	WERROR Clone(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct MInterfacePointer **ppNewCopy, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Clone r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Clone(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppNewCopy = *r.out.ppNewCopy;
		return r.out.result;
	}
	
	/* GetNames */
	WERROR GetNames(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetNames r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_GetNames(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* BeginEnumeration */
	WERROR BeginEnumeration(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, int32_t lFlags, TALLOC_CTX *mem_ctx = NULL)
	{
		struct BeginEnumeration r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.lFlags = lFlags;
		
		status = dcerpc_BeginEnumeration(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Next */
	WERROR Next(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Next r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Next(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* EndEnumeration */
	WERROR EndEnumeration(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct EndEnumeration r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_EndEnumeration(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* SetValue */
	WERROR SetValue(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct SetValue r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_SetValue(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* GetValue */
	WERROR GetValue(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetValue r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_GetValue(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* DeleteValue */
	WERROR DeleteValue(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct DeleteValue r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_DeleteValue(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* DeleteAll */
	WERROR DeleteAll(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct DeleteAll r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_DeleteAll(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
};


%inline {
struct IWbemLevel1Login { struct dcerpc_pipe *pipe; };
}

%extend IWbemLevel1Login {
	IWbemLevel1Login (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IWbemLevel1Login *ret = talloc(mem_ctx, struct IWbemLevel1Login);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IWbemLevel1Login, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IWbemLevel1Login() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* EstablishPosition */
	WERROR EstablishPosition(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct EstablishPosition r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_EstablishPosition(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* RequestChallenge */
	WERROR RequestChallenge(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct RequestChallenge r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_RequestChallenge(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* WBEMLogin */
	WERROR WBEMLogin(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct WBEMLogin r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_WBEMLogin(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* NTLMLogin */
	WERROR NTLMLogin(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, const char *wszNetworkResource, const char *wszPreferredLocale, int32_t lFlags, struct MInterfacePointer *pCtx, struct MInterfacePointer **ppNamespace, TALLOC_CTX *mem_ctx = NULL)
	{
		struct NTLMLogin r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.wszNetworkResource = wszNetworkResource;
		r.in.wszPreferredLocale = wszPreferredLocale;
		r.in.lFlags = lFlags;
		r.in.pCtx = pCtx;
		
		status = dcerpc_NTLMLogin(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppNamespace = *r.out.ppNamespace;
		return r.out.result;
	}
	
};


%inline {
struct IWbemWCOSmartEnum { struct dcerpc_pipe *pipe; };
}

%extend IWbemWCOSmartEnum {
	IWbemWCOSmartEnum (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IWbemWCOSmartEnum *ret = talloc(mem_ctx, struct IWbemWCOSmartEnum);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IWbemWCOSmartEnum, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IWbemWCOSmartEnum() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* IWbemWCOSmartEnum_Next */
	WERROR Next(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *gEWCO, uint32_t lTimeOut, uint32_t uCount, uint32_t *puReturned, uint32_t *pSize, uint8_t **pData, TALLOC_CTX *mem_ctx = NULL)
	{
		struct IWbemWCOSmartEnum_Next r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.gEWCO = gEWCO;
		r.in.lTimeOut = lTimeOut;
		r.in.uCount = uCount;
		
		status = dcerpc_IWbemWCOSmartEnum_Next(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*puReturned = *r.out.puReturned;
		*pSize = *r.out.pSize;
		*pData = *r.out.pData;
		return r.out.result;
	}
	
};

/* WBEMDATA */
/* WTYPES */
/* WBEMDATA4 */
/* WBEMDATA3 */
/* WBEMDATA2 */
/* WBEMDATA1 */
/* WBEMDATA0 */

%inline {
struct IWbemFetchSmartEnum { struct dcerpc_pipe *pipe; };
}

%extend IWbemFetchSmartEnum {
	IWbemFetchSmartEnum (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IWbemFetchSmartEnum *ret = talloc(mem_ctx, struct IWbemFetchSmartEnum);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IWbemFetchSmartEnum, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IWbemFetchSmartEnum() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Fetch */
	WERROR Fetch(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct MInterfacePointer **ppEnum, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Fetch r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Fetch(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppEnum = *r.out.ppEnum;
		return r.out.result;
	}
	
	/* Test */
	WERROR Test(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct WbemClassObject **ppEnum, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Test r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Test(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppEnum = *r.out.ppEnum;
		return r.out.result;
	}
	
};


%inline {
struct IWbemCallResult { struct dcerpc_pipe *pipe; };
}

%extend IWbemCallResult {
	IWbemCallResult (const char *binding, struct cli_credentials *cred = NULL, TALLOC_CTX *mem_ctx = NULL, struct event_context *event = NULL)
	{
		struct IWbemCallResult *ret = talloc(mem_ctx, struct IWbemCallResult);
		NTSTATUS status;
		
		status = dcerpc_pipe_connect(mem_ctx, &ret->pipe, binding, &dcerpc_table_IWbemCallResult, cred, event);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return NULL;
		}
		
		return ret;
	}
	
	~IWbemCallResult() {
		talloc_free(self);
	}
	
	/* QueryInterface */
	WERROR QueryInterface(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, struct GUID *iid, struct MInterfacePointer **data, TALLOC_CTX *mem_ctx = NULL)
	{
		struct QueryInterface r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.iid = iid;
		
		status = dcerpc_QueryInterface(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*data = *r.out.data;
		return r.out.result;
	}
	
	/* AddRef */
	uint32_t AddRef(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct AddRef r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_AddRef(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* Release */
	uint32_t Release(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, TALLOC_CTX *mem_ctx = NULL)
	{
		struct Release r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		
		status = dcerpc_Release(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* GetResultObject */
	WERROR GetResultObject(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, int32_t lTimeout, struct MInterfacePointer **ppResultObject, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetResultObject r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.lTimeout = lTimeout;
		
		status = dcerpc_GetResultObject(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppResultObject = *r.out.ppResultObject;
		return r.out.result;
	}
	
	/* GetResultString */
	WERROR GetResultString(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, int32_t lTimeout, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetResultString r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.lTimeout = lTimeout;
		
		status = dcerpc_GetResultString(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		return r.out.result;
	}
	
	/* GetResultServices */
	WERROR GetResultServices(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, int32_t lTimeout, struct MInterfacePointer **ppServices, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetResultServices r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.lTimeout = lTimeout;
		
		status = dcerpc_GetResultServices(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*ppServices = *r.out.ppServices;
		return r.out.result;
	}
	
	/* GetCallStatus */
	WERROR GetCallStatus(struct ORPCTHAT *ORPCthat, struct ORPCTHIS ORPCthis, int32_t lTimeout, int32_t *plStatus, TALLOC_CTX *mem_ctx = NULL)
	{
		struct GetCallStatus r;
		NTSTATUS status;
		
		/* Fill r structure */
		r.in.ORPCthis = ORPCthis;
		r.in.lTimeout = lTimeout;
		
		status = dcerpc_GetCallStatus(self->pipe, mem_ctx, &r);
		if (NT_STATUS_IS_ERR(status)) {
			ntstatus_exception(status);
			return r.out.result;
		}
		
		/* Set out arguments */
		*ORPCthat = *r.out.ORPCthat;
		*plStatus = *r.out.plStatus;
		return r.out.result;
	}
	
};


